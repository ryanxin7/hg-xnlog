<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>kubernetes 中的网络实现方式 - Ryan&#39;s Notebook</title><meta name="author" content="Ryan">
<meta name="author-link" content="https://github.com/ryanxin7">
<meta name="description" content="1.kubernetes 网络通信方案简介 Kubernetes 的网络涉及到各种 Pod 之间的通信以及 Pod 与外部网络的连接。而 Kubernetes 的网络实现通常依赖于第三方网络插件，这些插件需要遵循一定的规范，" /><meta name="keywords" content='kubernetes网络, cni, flannel, docker, calico' /><meta itemprop="name" content="kubernetes 中的网络实现方式">
<meta itemprop="description" content="1.kubernetes 网络通信方案简介 Kubernetes 的网络涉及到各种 Pod 之间的通信以及 Pod 与外部网络的连接。而 Kubernetes 的网络实现通常依赖于第三方网络插件，这些插件需要遵循一定的规范，"><meta itemprop="datePublished" content="2024-01-08T00:00:00+00:00" />
<meta itemprop="dateModified" content="2024-01-08T00:00:00+00:00" />
<meta itemprop="wordCount" content="18710"><meta itemprop="image" content="https://hg-xnlog.github.io/logo.png"/>
<meta itemprop="keywords" content="kubernetes网络,cni,flannel,docker,calico," /><meta property="og:title" content="kubernetes 中的网络实现方式" />
<meta property="og:description" content="1.kubernetes 网络通信方案简介 Kubernetes 的网络涉及到各种 Pod 之间的通信以及 Pod 与外部网络的连接。而 Kubernetes 的网络实现通常依赖于第三方网络插件，这些插件需要遵循一定的规范，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hg-xnlog.github.io/posts/kubernetes/primary/networking-implementation-in-kubernetes/" /><meta property="og:image" content="https://hg-xnlog.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-08T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-01-08T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://hg-xnlog.github.io/logo.png"/>

<meta name="twitter:title" content="kubernetes 中的网络实现方式"/>
<meta name="twitter:description" content="1.kubernetes 网络通信方案简介 Kubernetes 的网络涉及到各种 Pod 之间的通信以及 Pod 与外部网络的连接。而 Kubernetes 的网络实现通常依赖于第三方网络插件，这些插件需要遵循一定的规范，"/>
<meta name="application-name" content="Ryan’s Notebook">
<meta name="apple-mobile-web-app-title" content="Ryan’s Notebook"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/images/favicon.svg"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://hg-xnlog.github.io/posts/kubernetes/primary/networking-implementation-in-kubernetes/" /><link rel="prev" href="https://hg-xnlog.github.io/posts/kubernetes/primary/kubernetes-rbac-and-multi-user-instances/" /><link rel="next" href="https://hg-xnlog.github.io/posts/kubernetes/primary/kubernetes%E9%85%8D%E7%BD%AEimagepullsecrets%E7%A7%98%E9%92%A5%E6%9D%A5%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "kubernetes 中的网络实现方式",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/hg-xnlog.github.io\/posts\/kubernetes\/primary\/networking-implementation-in-kubernetes\/"
    },"genre": "posts","keywords": "kubernetes网络, cni, flannel, docker, calico","wordcount":  18710 ,
    "url": "https:\/\/hg-xnlog.github.io\/posts\/kubernetes\/primary\/networking-implementation-in-kubernetes\/","datePublished": "2024-01-08T00:00:00+00:00","dateModified": "2024-01-08T00:00:00+00:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "Ryan"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper" data-page-style="wide"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper" data-github-corner="right">
    <div class="header-title">
      <a href="/" title="Ryan&#39;s Notebook"><img loading="lazy" src="/images/pow.png" srcset="/images/pow.png, /images/pow.png 1.5x, /images/pow.png 2x" sizes="auto" data-title="Ryan&#39;s Notebook" data-alt="Ryan&#39;s Notebook" class="logo" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/><span class="header-title-text">Ryan’s Notebook</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/posts/"
                
                
              ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 所有文章</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/friends/"
                title="友情链接"
                
              ><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden="true"></i> 友链</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/about/"
                
                
              ><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden="true"></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id="search-desktop">
            <input type="text" placeholder="搜索文章标题或内容……" id="search-input-desktop">
            <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
              <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
            </a>
            <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
              <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
            </a>
            <span class="search-button search-loading" id="search-loading-desktop">
              <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
            </span>
          </li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="Ryan&#39;s Notebook"><img loading="lazy" src="/images/pow.png" srcset="/images/pow.png, /images/pow.png 1.5x, /images/pow.png 2x" sizes="auto" data-title="/images/pow.png" data-alt="/images/pow.png" class="logo" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/><span class="header-title-text">Ryan’s Notebook</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="search-wrapper">
            <div class="search mobile" id="search-mobile">
              <input type="text" placeholder="搜索文章标题或内容……" id="search-input-mobile">
              <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
              </a>
              <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
              </a>
              <span class="search-button search-loading" id="search-loading-mobile">
                <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
              </span>
            </div>
            <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
              取消
            </a>
          </li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/posts/"
                  
                  
                ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 所有文章</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/friends/"
                  title="友情链接"
                  
                ><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden="true"></i> 友链</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/about/"
                  
                  
                ><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden="true"></i> 关于</a></li><li
              class="menu-item text-center"
            ><a
                  class="menu-link"
                  href="https://github.com/ryanxin7/hg-xnlog"
                  title="GitHub"
                  rel="noopener noreferrer" target="_blank"
                ><i class='fa-brands fa-github fa-fw' aria-hidden='true'></i> </a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="切换主题"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
  </div>
  <div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
  </div><main class="container"><aside class="toc" id="toc-auto"><h2 class="toc-title">目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside>

  <aside class="aside-custom">
    </aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>kubernetes 中的网络实现方式</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><a href="https://github.com/ryanxin7" title="作者"target="_blank" rel="external nofollow noopener noreferrer author" class="author"><img loading="lazy" src="/images/avatar.png" srcset="/images/avatar.png, /images/avatar.png 1.5x, /images/avatar.png 2x" sizes="auto" data-title="Ryan" data-alt="Ryan" class="avatar" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/>&nbsp;Ryan</a></span>
          <span class="post-category">收录于 <a href="/categories/kubernetes/"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> Kubernetes</a></span></div>
      <div class="post-meta-line"><span title="发布于 2024-01-08 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden="true"></i><time datetime="2024-01-08">2024-01-08</time></span>&nbsp;<span title="更新于 2024-01-08 00:00:00"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden="true"></i><time datetime="2024-01-08">2024-01-08</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>约 18710 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>预计阅读 38 分钟</span>&nbsp;<span id="busuanzi_container_page_pv" class="busuanzi_visitors comment-visitors" data-flag-title="kubernetes 中的网络实现方式">
            <i class="fa-regular fa-eye fa-fw me-1" aria-hidden="true"></i><span id="busuanzi_value_page_pv">-</span>&nbsp;次阅读
          </span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1kubernetes-网络通信方案简介">1.kubernetes 网络通信方案简介</a></li>
    <li><a href="#2kubernetes-中pod通信场景">2.kubernetes 中Pod通信场景</a>
      <ul>
        <li><a href="#21-同一个-pod-内的不同容器的通信">2.1 同一个 Pod 内的不同容器的通信</a></li>
        <li><a href="#22-分布式-pod-间的通信">2.2 分布式 Pod 间的通信</a></li>
        <li><a href="#23-pod-和服务service之间的通信">2.3 Pod 和服务Service之间的通信</a></li>
      </ul>
    </li>
    <li><a href="#3cni插件三种常见实现方式">3.CNI插件三种常见实现方式</a>
      <ul>
        <li><a href="#21-overlay-覆盖模式">2.1 Overlay 覆盖模式</a></li>
        <li><a href="#22-routing-路由模式">2.2 Routing 路由模式</a></li>
        <li><a href="#23-underlay网络模型">2.3 Underlay网络模型</a></li>
      </ul>
    </li>
    <li><a href="#4flannel网络插件">4.Flannel网络插件</a>
      <ul>
        <li><a href="#41-flannel-配置">4.1 Flannel 配置</a></li>
        <li><a href="#42-flannel-后端容器网络机制简介">4.2 Flannel 后端容器网络机制简介</a></li>
        <li><a href="#43--vxlan">4.3  VXLAN</a></li>
        <li><a href="#44-directrouting-直接路由">4.4 DirectRouting 直接路由</a></li>
        <li><a href="#45-host-gw">4.5 host-gw</a></li>
      </ul>
    </li>
    <li><a href="#5calico网络插件">5.Calico网络插件</a>
      <ul>
        <li><a href="#51-calico-工作原理">5.1 Calico 工作原理</a></li>
        <li><a href="#52-node-to-node-mesh模式">5.2 node-to-node mesh模式</a></li>
        <li><a href="#53-route-reflector-模式rr路由反射">5.3 Route Reflector 模式（RR路由反射）</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><h2 id="1kubernetes-网络通信方案简介">1.kubernetes 网络通信方案简介</h2>
<p>Kubernetes 的网络涉及到各种 Pod 之间的通信以及 Pod 与外部网络的连接。而 Kubernetes 的网络实现通常依赖于第三方网络插件，这些插件需要遵循一定的规范，其中最为常见和广泛支持的规范之一就是 CNI（Container Network Interface）。</p>
<p>CNI 是由 CoreOS 和 Google 联合制定的规范，旨在定义容器运行时和网络插件之间的标准接口。这个标准定义了插件应该如何配置网络，并提供了一种统一的方法来实现容器网络的连接和管理。</p>
<p><a href="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/"target="_blank" rel="external nofollow noopener noreferrer">CNI简介</a>     <a href="https://github.com/containernetworking/cni/blob/spec-v0.4.0/SPEC.md"target="_blank" rel="external nofollow noopener noreferrer">CNI版本</a></p>
<p>在 Kubernetes 生态系统中，Calico 和 Flannel 是两个常用的 CNI（Container Network Interface）网络插件，它们都提供了不同的网络方案和功能，适用于不同的场景和需求。</p>
<p><strong>Flannel</strong></p>
<ul>
<li>提供简单且易于部署的网络解决方案，基于虚拟网络（Overlay Network）实现 Pod 之间的通信。</li>
<li>采用不同的网络后端技术，如 VXLAN、UDP 或者 host-gw 模式，以提供不同的性能和适应不同的网络环境。</li>
</ul>
<p><strong>Calico</strong></p>
<ul>
<li>
<p>提供了基于 BGP 的 IP 网络方案，支持高度可扩展的容器网络。</p>
</li>
<li>
<p>支持网络策略（Network Policies），允许对 Pod 之间的通信进行细粒度的控制和限制。</p>
</li>
<li>
<p>支持跨节点的网络互联，可用于多节点的 Kubernetes 集群，并提供了灵活的网络拓扑。</p>
</li>
</ul>
<p>在公有云环境中，因为 Calico 通常需要与云提供商的底层网络结合并支持 BGP，而有些云服务商可能限制了 BGP 的使用，因此在这种情况下，部署 Flannel 可能更为方便。</p>
<!-- raw HTML omitted -->
<h2 id="2kubernetes-中pod通信场景">2.kubernetes 中Pod通信场景</h2>
<h3 id="21-同一个-pod-内的不同容器的通信">2.1 同一个 Pod 内的不同容器的通信</h3>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/1_-ze224LkGbwRbgIC-7w5dg.webp" srcset="https://cdn1.ryanxin.live/1_-ze224LkGbwRbgIC-7w5dg.webp, https://cdn1.ryanxin.live/1_-ze224LkGbwRbgIC-7w5dg.webp 1.5x, https://cdn1.ryanxin.live/1_-ze224LkGbwRbgIC-7w5dg.webp 2x" sizes="auto" data-title="https://cdn1.ryanxin.live/1_-ze224LkGbwRbgIC-7w5dg.webp" data-alt="https://cdn1.ryanxin.live/1_-ze224LkGbwRbgIC-7w5dg.webp" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>​       Kubernetes中的Pod是调度的最小单位，可包含一个或多个容器。Pod内的多个容器共享相同的网络和存储空间，它们通过本地主机上的localhost接口直接进行本地通信，类似于同一主机上的多个进程间的通信。这种通信方式是通过一个名为pause的基础架构容器来实现的，pause容器管理Pod的网络命名空间，使得容器能够共享网络栈，从而实现高效的本地通信。</p>
<h3 id="22-分布式-pod-间的通信">2.2 分布式 Pod 间的通信</h3>
<p>​     分布式 Pod 间的通信以及 Pod 与 Node 间的通信都建立在共享的平面网络上。这个共享的平面网络依赖于容器网络插件（CNI），这些插件允许 Kubernetes 集群中的不同节点上的 Pod 之间直接通信。每个 Pod 对象都有一个虚拟网络接口和一个集群全局唯一的 IP 地址，这个 IP 地址可以直接用于 Pod 之间的通信。运行 Pod 的各个节点也会持有一个属于同一平面网络的 IP 地址，通常是通过桥接设备（例如 cni0 接口）来实现。Node 与 Pod 之间的通信也可以直接在这个共享的网络中进行。因此，不论是 Pod 之间的通信还是 Pod 与 Node 之间的通信，都类似于在同一 IP 网络中的主机间进行的通信。</p>
<h3 id="23-pod-和服务service之间的通信">2.3 Pod 和服务Service之间的通信</h3>
<!-- raw HTML omitted -->
<p>​      Service与Pod之间的通信发生在称为集群网络的专用网络中。启动kube-apiserver时，需使用<code>--service-cluster-ip-range</code>选项指定该网络范围，例如默认值为10.96.0.0/12。在该网络中，每个Service对象都有一个称为Cluster-IP的固定地址。</p>
<p>当管理员或用户创建或修改Service对象时，这些操作会被API Server存储。随后，kube-proxy在每个节点上被触发。根据代理模式的设置，该Service对象会被定义为相应节点上的iptables规则或ipvs规则。Pod或节点客户端发起访问Service对象IP地址的请求时，这些iptables或ipvs规则会进行调度和转发，从而促成Pod与Service之间的通信。</p>
<p><strong>Pod 与 Kubernetes 外部的网络通信</strong></p>
<!-- raw HTML omitted -->
<p>外部到 Pod（客户端请求）:</p>
<p>使用 Kubernetes 的 Ingress 资源或者 Service 类型为 LoadBalancer/NodePort 的服务，将外部请求路由到集群内部的 Pod。Ingress 允许管理外部访问到集群中的服务。</p>
<p>Pod 到外部（响应报文）:</p>
<p>当 Pod 中的容器需要向外部服务发送响应时，通常情况下，Pod 内的容器可以通过集群外部的服务地址或者外部 IP 地址来实现与外部通信的响应报文。可以创建一个 Service 类型为 ExternalName，将该 Service 映射到集群外部的服务域名或 IP 地址。如果有代理或中间件可以代表 Pod 中的容器访问外部服务，则可以创建一个 Service 类型为 ClusterIP 的服务，并配置代理或中间件来转发请求到外部服务。</p>
<!-- raw HTML omitted -->
<h2 id="3cni插件三种常见实现方式">3.CNI插件三种常见实现方式</h2>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/202304071680855692400423.png" srcset="https://cdn1.ryanxin.live/202304071680855692400423.png, https://cdn1.ryanxin.live/202304071680855692400423.png 1.5x, https://cdn1.ryanxin.live/202304071680855692400423.png 2x" sizes="auto" data-title="image.png" data-alt="image.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h3 id="21-overlay-覆盖模式">2.1 Overlay 覆盖模式</h3>
<p>跨网段的容器通信通过 Overlay 网络进行，这种方式通过在不同节点之间建立隧道，将容器的通信流量封装在数据包中传输。
这种模式不依赖于底层网络，可以在不同的底层网络架构上工作，但因为数据包的封装和解封装过程，可能会带来性能损耗。</p>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/245df37eefe424dfb8c17330bf523424.jpg" srcset="https://cdn1.ryanxin.live/245df37eefe424dfb8c17330bf523424.jpg, https://cdn1.ryanxin.live/245df37eefe424dfb8c17330bf523424.jpg 1.5x, https://cdn1.ryanxin.live/245df37eefe424dfb8c17330bf523424.jpg 2x" sizes="auto" data-title="img" data-alt="img" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h4 id="211-overlay-网络模型">2.1.1 Overlay 网络模型</h4>
<p><strong>VxLAN</strong>：VxLAN全称是Visual eXtensible Local Area Network（虚拟扩展本地局域网），主要由Cisco推出，vxlan是一个VLAN的扩展协议，是由IETF定义的NVO3（Network Virtualization over Layer 3）标准技术之一，VXLAN的特点是将L2的以太帧封装到UDP报文（即L2 over L4）中，并在L3网络中传输，即使用MAC in UDP的方法对报文进行重新封装，VxLAN本质上是一种overlay的隧道封装技术，它将L2的以太网帧封装成L4的UDP数据包，然后在L3的网络中传输，效果就像L2的以太网帧在一个广播域中传输一样，实际上L2的以太网帧跨越了L3网络传输，但是却不受L3网络的限制，vxlan采用24位标识vlan ID号，因此可以支持2^24=1677216个vlan，其可扩展性比vlan强大的多，可以技术大规模数据中心的网络需求。</p>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/image-20240110160658360.png" srcset="https://cdn1.ryanxin.live/image-20240110160658360.png, https://cdn1.ryanxin.live/image-20240110160658360.png 1.5x, https://cdn1.ryanxin.live/image-20240110160658360.png 2x" sizes="auto" data-title="image-20240110160658360" data-alt="image-20240110160658360" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p><strong>VTEP （VXLAN Tunnel Endpoint）</strong>：VTEP 是 VXLAN 网络的边缘设备，作为 VXLAN 隧道的起点和终点，负责 VXLAN 数据包的封装和解封装。VTEP 设备对用户原始数据帧进行 VXLAN 封装（加入 VXLAN 头部）和解封装（去除 VXLAN 头部）。每对 VTEP 地址对应一个 VXLAN 隧道，以实现不同节点间的通信。服务器上的虚拟交换机（隧道 flannel.1 就是VTEP），比如一个虚拟机网络中的多个vxlan就需要多个VTEP对不同网络的报文进行封装与解封装。</p>
<p><strong>VNI（VXLAN Network Identifier）</strong>：VNI 类似于 VLAN ID，在 VXLAN 中用于标识不同的 VXLAN 段或虚拟网络。每个 VNI 表示一个租户或者一个虚拟网络，允许对不同的虚拟网络进行隔离和标识。VNI 用于区分不同的 VXLAN 段，确保不同 VNI 的虚拟机或容器之间不能直接连接二层通信，实现租户间的隔离。多个终端用户或虚拟机属于同一个 VNI 表示它们属于同一个租户或虚拟网络。</p>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/kube-network-model-vxlan.png" srcset="https://cdn1.ryanxin.live/kube-network-model-vxlan.png, https://cdn1.ryanxin.live/kube-network-model-vxlan.png 1.5x, https://cdn1.ryanxin.live/kube-network-model-vxlan.png 2x" sizes="auto" data-title="img" data-alt="img" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<ol>
<li><strong>veth1</strong>：veth1是（veth pair）中的一个端点，veth pair 是容器和宿主机网络之间的虚拟以太网设备，由容器运行时（例如 Docker、Containerd 等）在创建容器时自动创建。并将一端附加到容器内部，这个端点通常被命名为 veth1 或类似的名称。同时，另一端会被自动连接到宿主机的网络命名空间中这个虚拟设备允许容器内的网络流量与宿主机的网络进行通信，是宿主机上的容器与宿主机网络之间的桥梁。</li>
<li><strong>cni0：</strong> <code>cni0</code> 设备通常是由容器网络插件（CNI 插件）创建的，它用作容器网络中的虚拟网桥或虚拟网络接口。这个虚拟设备（<code>cni0</code>）的创建通常是由容器运行时（如 Docker、Containerd 等）与所选的 CNI 插件协作完成的。当容器网络插件被初始化和配置后，它可能会创建 <code>cni0</code> 这样的虚拟网桥，用于连接不同的容器和宿主机网络之间的通信。</li>
<li><strong>flannel.1：</strong> <code>flannel.1</code> 是 Flannel 网络插件创建的虚拟网络接口，用于实现 Kubernetes 集群中 Pod 之间的通信。Flannel 是一个网络覆盖（overlay）解决方案，通过创建虚拟网络层（例如使用 VXLAN 或者其他技术）实现不同节点上 Pod 之间的直接通信。</li>
</ol>
<h4 id="212-vxlan通信过程">2.1.2 VXLAN通信过程</h4>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/image-20240110160949702.png" srcset="https://cdn1.ryanxin.live/image-20240110160949702.png, https://cdn1.ryanxin.live/image-20240110160949702.png 1.5x, https://cdn1.ryanxin.live/image-20240110160949702.png 2x" sizes="auto" data-title="image-20240110160949702" data-alt="image-20240110160949702" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>VXLAN（Virtual Extensible LAN）是一种网络虚拟化技术，用于扩展虚拟局域网（VLAN）的数量。它主要用于在数据中心网络中创建虚拟网络以实现跨子网的通信。以下是 VXLAN 通信过程的简要描述：</p>
<ol>
<li>
<p><strong>封装（Encapsulation）：</strong></p>
<ul>
<li>发送端（源节点）：当源节点的某个设备（例如容器或虚拟机）需要发送数据包给另一个网络中的设备时，首先将数据包封装在 VXLAN 包中。</li>
<li>VXLAN 封装包：在封装过程中，会给原始数据包加上 VXLAN 头部信息。这个头部包含了 VXLAN 网络标识符（VNI，VXLAN Network Identifier）和其他元数据信息。</li>
</ul>
</li>
<li>
<p><strong>发送（Transmission）：</strong></p>
<ul>
<li>VXLAN 封装后的数据包通过底层物理网络传输到目标设备所在的节点。这可能需要通过路由器、交换机等设备来进行数据包的传输。</li>
</ul>
</li>
<li>
<p><strong>解封装（Decapsulation）：</strong></p>
<ul>
<li>接收端（目标节点）：一旦 VXLAN 封装的数据包到达目标节点，目标设备将进行解封装操作。</li>
<li>解封装：目标设备将从接收到的数据包中提取出原始数据，并根据 VNI 识别出数据包的所属虚拟网络。</li>
</ul>
</li>
<li>
<p><strong>转发至目标设备：</strong></p>
<ul>
<li>解封装后的原始数据包根据其 VNI 进行处理，并交付给目标设备（容器、虚拟机等）。</li>
</ul>
</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1py4y1a7iE"target="_blank" rel="external nofollow noopener noreferrer">https://www.bilibili.com/video/BV1py4y1a7iE</a></p>
<!-- raw HTML omitted -->
<h3 id="22-routing-路由模式">2.2 Routing 路由模式</h3>
<p>​    直接路由网络模型不再强调跨主机容器之间在二层（L2）的连通性，而是专注于在三层（L3）通过路由协议提供容器间的通信。这种解决方案更容易集成到现有数据中心的基础设施中，能够方便地连接容器和主机，并且在报文过滤和隔离方面具有更好的扩展能力和更精细的控制模型，因此成为了容器化网络中较流行的解决方案之一。</p>
<p>​    在典型的直接路由解决方案中，每个主机上的各个容器在二层网络中通过网桥进行通信，网关指向当前主机上的网桥接口地址。对于跨主机的容器间通信，需要依据主机上的路由表指示来完成报文的路由。因此，每个主机的物理接口地址都有可能成为另一个主机路由报文中的“下一跳”，这就要求各个主机的物理接口必须位于同一个二层网络中。这种模型的优势在于其能够更好地整合到现有网络基础设施中，提供更灵活、更可控的通信方式，并且更适用于需要精细控制报文流向和过滤的场景。以下是直接路由解决方案的示意图</p>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/2719436-20220221111838595-1369378462.png" srcset="https://cdn1.ryanxin.live/2719436-20220221111838595-1369378462.png, https://cdn1.ryanxin.live/2719436-20220221111838595-1369378462.png 1.5x, https://cdn1.ryanxin.live/2719436-20220221111838595-1369378462.png 2x" sizes="auto" data-title="img" data-alt="img" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<!-- raw HTML omitted -->
<p><strong>直接路由的宿主机需要在同一个网段，不能跨网段进行访问，这是直接路由模式的一个硬限制。</strong></p>
<p>以及在如何在大规模主机集群中维护路由表信息？</p>
<p><strong>常见的解决方案有：</strong></p>
<ul>
<li><strong>Flannel host-gw：</strong> Flannel host-gw 模式通过使用存储总线 etcd 并在每个节点上运行的 flanneld 进程，动态地维护路由表信息。这种方式允许容器间的直接路由，将它们与宿主机的路由信息相联系，以便在集群内进行通信。</li>
<li><strong>Calico BGP 协议：</strong> Calico 使用 BGP（边界网关协议）在主机集群中自动分发和学习路由信息。与 Flannel host-gw 不同的是，Calico 不会为容器在主机上使用网桥，而是为每个容器生成一对 veth 设备，并在主机上生成目标地址，作为当前容器的路由条目。这种方式更为灵活，并且利用 BGP 协议动态分发路由信息，实现容器间的通信。</li>
</ul>
<h3 id="23-underlay网络模型">2.3 Underlay网络模型</h3>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/2719436-20220221111633223-1852355686.png" srcset="https://cdn1.ryanxin.live/2719436-20220221111633223-1852355686.png, https://cdn1.ryanxin.live/2719436-20220221111633223-1852355686.png 1.5x, https://cdn1.ryanxin.live/2719436-20220221111633223-1852355686.png 2x" sizes="auto" data-title="img" data-alt="img" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>Underlay网络是指底层的物理网络基础设施，包括传统的企业IT网络，由交换机、路由器等物理设备组成，通过以太网、路由协议、VLAN 等技术驱动的网络。它是 Overlay 网络的底层基础，为 Overlay 网络提供基本的数据传输服务。</p>
<p>在容器网络中，Underlay网络是指通过特定的驱动程序将宿主机底层的网络接口直接暴露给容器使用的一种网络构建技术。这种技术允许容器直接访问宿主机底层的网络资源，而不需要通过额外的网络虚拟化层（例如 Overlay 网络）。</p>
<p>常见的容器网络的 Underlay 构建技术包括：</p>
<ul>
<li><strong>MAC VLAN（MAC Virtual LAN）：</strong> 允许将一个或多个容器连接到底层物理网络，为每个容器分配唯一的 MAC 地址。容器的网络流量会直接通过底层物理网络进行传输。</li>
<li><strong>IP VLAN（IP Virtual LAN）：</strong> 类似于 MAC VLAN，但在 IP 层面上为容器分配唯一的 IP 地址，并允许容器与物理网络进行直接通信。</li>
<li><strong>直接路由（Direct Routing）：</strong> 允许容器直接访问底层物理网络，并通过主机的路由表进行数据转发，使容器的网络流量可以绕过额外的网络虚拟化层。</li>
</ul>
<p>Underlay 模式依赖底层网络的特性和能力来实现容器间的通信，它会直接利用底层网络的能力打通不同节点或者不同网络的通信。</p>
<p>这种模式对底层网络的要求更高，通常能够获得更好的性能，但它也更强烈地依赖于底层网络的稳定性和可靠性。</p>
<hr>
<h4 id="231-mac-vlan">2.3.1 MAC VLAN</h4>
<p><strong>MAC VLAN有Private、VEPA、Bridge和Passthru几种工作模式，它们各自的工作特性如下</strong>  ：</p>
<ul>
<li>
<p>Private：禁止构建在同一物理接口上的多个MAC VLAN实例（容器接口）彼此间的通信，即便外部的物理交换机支持“发夹模式”也不行，同一父接口下的子接口之间彼此隔离，不能通信，及时通过外部交换机转发也不行</p>
</li>
<li>
<p>VPEA：允许构建在同一物理接口上的多个MAC VLAN实例（容器接口）彼此间的通信，但需要外部交换机启用发夹模式，或者存在报文转发功能的路由器设备 简单来说：vepa 模式下，子接口之间的通信流量需要导到外部支持802.1Qbg/VPEA 功能的交换机上（可以是物理的或者虚拟的）， 经由外部交换机转发，再绕回来</p>
</li>
<li>
<p>Bridge：将物理接口配置为网桥，从而允许同一物理接口上的多个MAC VLAN实例基于此网桥直接通信，而无须依赖外部的物理交换机来交换报文；此为最常用的模式，甚至还是Docker容器唯一支持的模式</p>
<p>简单来说：bridge 模式下，模拟的是Linux bridge 的功能，但比bridge 要好的一点是每个接口的MAC 地址是已知的，不用学习，所以这种模式下，子接口之间就是直接可以通信的</p>
</li>
<li>
<p>Passthru：允许其中一个MAC VLAN实例直接连接物理接口 简单来说：passthru 模式，只允许单个子接口连接父接口</p>
</li>
<li>
<p>source mode: 这种模式，只接收源mac 为指定的mac 地址的报文</p>
</li>
</ul>
<p>由上述工作模式可知，除了Passthru模式外的容器流量将被MAC VLAN过滤而无法与底层主机通信，从而将主机与其运行的容器完全隔离，其隔离级别甚至高于网桥式网络模型，这对于有多租户需求的场景尤为有用。由于各实例都有专用的MAC地址，因此MAC VLAN允许传输广播和多播流量，但它要求物理接口工作于混杂模式，考虑到很多公有云环境中并不允许使用混杂模式，这意味着MAC VLAN更适用于本地网络环境。 需要注意的是，MAC VLAN为每个容器使用一个唯一的MAC地址，这可能会导致具有安全策略以防止MAC欺骗的交换机出现问题，因为这类交换机的每个接口只允许连接一个MAC地址。另外，有些物理网卡存在可支撑的MAC地址数量上限</p>
<h4 id="232-ip-vlan">2.3.2 IP VLAN</h4>
<p>IP VLAN（也称为 IP 虚拟化）与 MAC VLAN 类似，它同样在物理网络接口上创建虚拟网络接口，并为每个虚拟接口分配唯一的 IP 地址。不同之处在于，IP VLAN 中每个虚拟接口共享物理接口的 MAC 地址，这样做避免了违反交换机安全策略中防止 MAC 欺骗的问题，并且不需要在物理接口上启用混杂模式。</p>
<h2 id="4flannel网络插件">4.Flannel网络插件</h2>
<p>官网：https://cores.com/flannel/docs/latest</p>
<p>文档：https://coreos.com/flannel/docs/latest/kubernetes.html</p>
<p>Flannel 主要解决容器跨节点通信问题。它利用虚拟网桥和 veth 设备为每个 Pod 创建虚拟网络接口，通过定义的后端（backend），能够为 Pod 之间提供通信网络。Flannel 支持多种平台，包括 Kubernetes、OpenShift、Cloud Foundry、Mesos、Amazon ECS、Singularity 和 OpenSVC 等。</p>
<p>Flannel 同时支持Overlay和Underlay网络模式，在Overlay模式下 Flannel 主要使用 VXLAN 和 VXLAN+DirectRouting（UDP模式现已不再支持），在Underlay网络模式下Flannel 也支持基于三层路由的 Underlay 网络，可以通过配置选择不同的网络模式来满足需求。</p>
<h3 id="41-flannel-配置">4.1 Flannel 配置</h3>
<p>在IP地址分配方面，它将预留的一个专用网络（默认为10.244.0.0/16，自定义为172.20.0.0/16）切分成多个子网后作为每个节点的Pod CIDR（Pod IP地址段），而后由节点以IPAM（IP Address Management）插件的host-local形式进行地址分配，并将子网分配信息保存于etcd之中。</p>
<p>可以在<code>/run/flannel/subnet.env</code>中查看子网的分配</p>
<div class="highlight" id="id-1"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1">#k8s-master1</span>
</span></span><span class="line"><span class="cl">root@k8s-master:~# cat /run/flannel/subnet.env 
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_NETWORK</span><span class="o">=</span>172.20.0.0/16  <span class="c1">#所在网段</span>
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_SUBNET</span><span class="o">=</span>172.20.0.1/24   <span class="c1">#分配给容器的IP网段</span>
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_MTU</span><span class="o">=</span><span class="m">1450</span>
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_IPMASQ</span><span class="o">=</span><span class="nb">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#k8s-node1(分配的172.20.2.0/24网段)</span>
</span></span><span class="line"><span class="cl">root@k8s-node1:~# cat /run/flannel/subnet.env 
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_NETWORK</span><span class="o">=</span>172.20.0.0/16  <span class="c1">#所在网段</span>
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_SUBNET</span><span class="o">=</span>172.20.2.1/24   <span class="c1">#分配给容器的IP网段</span>
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_MTU</span><span class="o">=</span><span class="m">1450</span>               
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_IPMASQ</span><span class="o">=</span><span class="nb">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#k8s-node2(分配的172.20.1.0/24网段)</span>
</span></span><span class="line"><span class="cl">root@k8s-node2:~# cat /run/flannel/subnet.env
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_NETWORK</span><span class="o">=</span>172.20.0.0/16
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_SUBNET</span><span class="o">=</span>172.20.1.1/24
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_MTU</span><span class="o">=</span><span class="m">1450</span>
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_IPMASQ</span><span class="o">=</span>true</span></span></code></pre></div><p>Flannel 在每个主机上运行一个名为 flanneld 的二进制代理程序，它负责从预留的网络中按照指定或默认的掩码长度为当前节点申请分配一个子网，并将网络配置、已分配的子网和辅助数据（例如主机的公网IP等）存储在Kubernetes API或etcd之中。</p>
<div class="highlight" id="id-2"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-deploy:~# kubectl get pod -n kube-system -o wide
</span></span><span class="line"><span class="cl">NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES
</span></span><span class="line"><span class="cl">coredns-7659f568f5-fz6t2 1/1 Running <span class="m">2</span> 2d6h 172.20.2.4 192.168.1.102 &lt;none&gt; &lt;none&gt;
</span></span><span class="line"><span class="cl">kube-flannel-ds-amd64-498cr 1/1 Running <span class="m">2</span> 2d6h 192.168.1.103 192.168.1.103 &lt;none&gt; &lt;none&gt;
</span></span><span class="line"><span class="cl">kube-flannel-ds-amd64-78kw5 1/1 Running <span class="m">1</span> 2d6h 192.168.1.101 192.168.1.101 &lt;none&gt; &lt;none&gt;
</span></span><span class="line"><span class="cl">kube-flannel-ds-amd64-cvqr7 1/1 Running <span class="m">2</span> 2d6h 192.168.1.102 192.168.1.102 &lt;none&gt; &lt;none&gt;</span></span></code></pre></div><h3 id="42-flannel-后端容器网络机制简介">4.2 Flannel 后端容器网络机制简介</h3>
<p><strong>Flannel 使用称为后端的容器网络机制来转发跨节点的 Pod 数据包。</strong></p>
<p>Flannel 支持多种后端技术，最常见的是 VXLAN 和 VXLAN+DirectRouting。</p>
<ol>
<li>**VXLAN：**使用 Linux 内核中的 VXLAN 模块进行隧道报文的封装，实现 Overlay 网络模型，支持跨节点的 Pod 之间的通信。支持直接路由模式(VXLAN+DirectRouting)，允许在同一二层网络内的节点间直接发送数据包。但是在跨网络的节点间的 Pod 通信仍然使用 VXLAN 隧道协议转发。</li>
<li>**Host-gw：**类似于 VXLAN 中的直接路由模式，但不支持跨网络的节点间通信。要求各节点必须在同一个二层网络中，不适用于大规模网络。具有较好的转发性能，易于设置，适用于对报文转发性能要求较高的场景。</li>
<li><strong>UDP：</strong> 使用常规 UDP 报文封装实现隧道转发，性能较前两种方式低。通常用于不支持前两种后端的环境。但值得注意的是，现在已不再支持 UDP 模式。</li>
</ol>
<p>Flannel使用etcd来存储虚拟IP和主机IP之间的映射，每个节点上运行的flanneld守护进程负责监视etcd中的信息并完成报文路由。默认情况下，Flannel的配置信息保存在etcd存储系统的键名<code>/coreos.com/network/config</code>之下。</p>
<p>kubernetes中会定义一个名为<code>kube-flannel-cfg</code>的configmaps，它的值是一个JSON格式的字典数据结构，它可以使用的键包含以下几个。</p>
<div class="highlight" id="id-3"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="err">root@k</span><span class="mi">8</span><span class="err">s-deploy:~#</span> <span class="err">kubectl</span> <span class="err">get</span> <span class="err">configmaps</span> <span class="err">kube-flannel-cfg</span> <span class="err">-n</span> <span class="err">kube-system</span>
</span></span><span class="line"><span class="cl"><span class="err">NAME</span>               <span class="err">DATA</span>   <span class="err">AGE</span>
</span></span><span class="line"><span class="cl"><span class="err">kube-flannel-cfg</span>   <span class="mi">2</span>      <span class="mi">2</span><span class="err">d</span><span class="mi">6</span><span class="err">h</span>
</span></span><span class="line"><span class="cl"><span class="err">root@k</span><span class="mi">8</span><span class="err">s-deploy:~#</span> <span class="err">kubectl</span> <span class="err">describe</span> <span class="err">configmaps</span> <span class="err">kube-flannel-cfg</span> <span class="err">-n</span> <span class="err">kube-system</span>
</span></span><span class="line"><span class="cl"><span class="err">Name:</span>         <span class="err">kube-flannel-cfg</span>
</span></span><span class="line"><span class="cl"><span class="err">Namespace:</span>    <span class="err">kube-system</span>
</span></span><span class="line"><span class="cl"><span class="err">Labels:</span>       <span class="err">app=flannel</span>
</span></span><span class="line"><span class="cl">              <span class="err">tier=node</span>
</span></span><span class="line"><span class="cl"><span class="err">Annotations:</span>  <span class="err">&lt;none&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">Data</span>
</span></span><span class="line"><span class="cl"><span class="err">====</span>
</span></span><span class="line"><span class="cl"><span class="err">cni-conf.json:</span>
</span></span><span class="line"><span class="cl"><span class="err">----</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;cbr0&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;cniVersion&#34;</span><span class="p">:</span> <span class="s2">&#34;0.3.1&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;plugins&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;flannel&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;delegate&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;hairpinMode&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;isDefaultGateway&#34;</span><span class="p">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;portmap&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;capabilities&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;portMappings&#34;</span><span class="p">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">net-conf.json:</span>
</span></span><span class="line"><span class="cl"><span class="err">----</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;Network&#34;</span><span class="p">:</span> <span class="s2">&#34;172.20.0.0/16&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;Backend&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;Type&#34;</span><span class="p">:</span> <span class="s2">&#34;vxlan&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">Events:</span>  <span class="err">&lt;none&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="mi">1</span><span class="err">）Network：Flannel在全局使用CIDR格式的IPv</span><span class="mi">4</span><span class="err">网络，字符串格式，此为必选键，余下的均为可选。</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="mi">2</span><span class="err">）SubnetLen：为全局使用的IPv</span><span class="mi">4</span><span class="err">网络基于多少位的掩码切割供各节点使用的子网，在全局网络的掩码小于</span><span class="mi">24</span><span class="err">（例如</span><span class="mi">16</span><span class="err">）时默认为</span><span class="mi">24</span><span class="err">位。</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="mi">3</span><span class="err">）SubnetMin：分配给节点使用的起始子网，默认为切分完成后的第一个子网；字符串格式。</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="mi">4</span><span class="err">）SubnetMax：分配给节点使用的最大子网，默认为切分完成后的最大一个子网；字符串格式。</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="mi">5</span><span class="err">）Backend：Flannel要使用的后端类型，以及后端相关的配置，字典格式；不同的后端通常会有专用的配置参数。</span></span></span></code></pre></div><p>Flannel预留使用的网络为默认的10.244.0.0/16，我们自定义的172.20.0.0/16，默认使用24位长度的子网掩码为各节点分配切分的子网，因而，它将有172.20.0.0/24～ 172.20.255.0/24范围内的256个子网可用，每个节点最多支持为254个Pod对象各分配一个IP地址。它使用的后端是VXLAN类型，flanneld将监听UDP的8472端口。</p>
<div class="highlight" id="id-4"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-master0:~# netstat -tunlp<span class="p">|</span>grep <span class="m">8472</span>
</span></span><span class="line"><span class="cl">udp        <span class="m">0</span>      <span class="m">0</span> 0.0.0.0:8472            0.0.0.0:*                           -    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">root@k8s-node1:~# netstat -tunlp<span class="p">|</span>grep <span class="m">8472</span>
</span></span><span class="line"><span class="cl">udp        <span class="m">0</span>      <span class="m">0</span> 0.0.0.0:8472            0.0.0.0:*      </span></span></code></pre></div><h3 id="43--vxlan">4.3  VXLAN</h3>
<h4 id="431-flannel-虚拟网桥">4.3.1 Flannel 虚拟网桥</h4>
<p>Flannel 在集群中的每个运行 flanneld 的节点上都会创建一个名为 <code>flannel.1</code> 的虚拟网桥作为本节点隧道的出入口的 **VTEP（VXLAN Tunnel Endpoint）**设备。在这里，<code>.1</code> 表示 VXLAN 网络标识符（VNI），因此所有节点上的 VTEP 都属于相同的 VXLAN ，Flannel 的这种设计允许集群中的各个节点在网络上形成一个统一的大二层域，使得 Pod 可以通过 VXLAN 隧道进行透明的跨节点通信。</p>
<p>Flannel 采用了分布式的网关模型。每个节点被视为到达该节点 Pod 子网的二层网关，并且相应的路由信息由 flanneld 自动生成， flanneld 会负责在每个节点上生成路由信息，以确保跨节点的 Pod 通信能够正确进行。当 Pod 需要与其他节点上的 Pod 通信时，相关的流量会经过 VXLAN 隧道，通过 flannel.1 虚拟网桥进行传输。</p>
<div class="highlight" id="id-5"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-node1:~# brctl show
</span></span><span class="line"><span class="cl">bridge name    bridge id        STP enabled    interfaces
</span></span><span class="line"><span class="cl">cni0        8000.6a27d0d1f4d3    no        veth1ebbd6d3
</span></span><span class="line"><span class="cl">docker0        8000.0242c905c787    no        
</span></span><span class="line"><span class="cl">root@k8s-node1:~# ip route show
</span></span><span class="line"><span class="cl">default via 192.168.1.1 dev eth0 proto static 
</span></span><span class="line"><span class="cl">172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 
</span></span><span class="line"><span class="cl">172.20.0.0/24 via 172.20.0.0 dev flannel.1 onlink 
</span></span><span class="line"><span class="cl">172.20.1.0/24 via 172.20.1.0 dev flannel.1 onlink 
</span></span><span class="line"><span class="cl">172.20.2.0/24 dev cni0 proto kernel scope link src 172.20.2.1 
</span></span><span class="line"><span class="cl">192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.102</span></span></code></pre></div><h4 id="432-flanneld-守护进程">4.3.2 flanneld 守护进程</h4>
<p><strong>flanneld 守护进程的主要职责</strong></p>
<p>当 flanneld 启动时，它会首先连接到 etcd 存储，通过 HTTP 请求获取保存在 etcd 中的网络配置信息， 在 etcd 中获取 JSON 格式的网络配置信息，这些信息描述了 Flannel 网络的各种参数，如网络类型（通常是 VXLAN）、子网分配范围、VXLAN 的 VNI 等。 接下来 flanneld对获取到的 JSON 格式的网络配置信息进行解析，从中提取出必要的配置参数。根据解析得到的配置信息，flanneld 确定 Flannel 网络的类型，通常是 VXLAN。同时，它确定用于分配子网的 IP 地址范围，即子网池。然后flanneld 根据确定的网络类型和子网范围，进行网络初始化工作。包括为每个节点分配唯一的子网租约、生成路由信息、创建虚拟网桥等操作。</p>
<p><strong>在与 Kubernetes 结合使用时，Flannel 可以通过 DaemonSet 控制器进行管理</strong>
在 Kubernetes 中，DaemonSet 是一种控制器，用于确保在集群的每个节点上运行一个副本的 Pod。这样可以确保在整个集群中的每个节点都有相同的 Pod 运行。Flannel 项目提供了一个名为 kube-flannel-ds 的 DaemonSet 控制器和其配置清单，其中包含了用于创建 kube-flannel-ds DaemonSet 控制器的 Kubernetes YAML 文件。这个清单定义了需要运行的容器镜像、Pod 的标签选择器、网络配置等信息。</p>
<p>在 <strong>kube-flannel-ds DaemonSet</strong> 控制器中，定义了一个 Pod 模板，其中包含 flanneld 容器的运行配置。这个 Pod 模板中使用了 hostNetwork: true，表示这些 Pod 共享宿主节点的网络命名空间。这样配置的结果是，flanneld 守护进程在每个节点的根网络命名空间中运行，能够直接影响整个节点的网络配置。</p>
<p>通过这种方式，kube-flannel-ds DaemonSet 控制器确保在每个节点上都运行了 flanneld 守护进程，并使得 Flannel 的网络配置能够在整个 Kubernetes 集群中生效。 <a href="https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml"target="_blank" rel="external nofollow noopener noreferrer">https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml</a></p>
<div class="highlight" id="id-6"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">DaemonSet</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">flannel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">k8s-app</span><span class="p">:</span><span class="w"> </span><span class="l">flannel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">tier</span><span class="p">:</span><span class="w"> </span><span class="l">node</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">kube-flannel-ds</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">kube-flannel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">flannel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">k8s-app</span><span class="p">:</span><span class="w"> </span><span class="l">flannel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">flannel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">k8s-app</span><span class="p">:</span><span class="w"> </span><span class="l">flannel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">tier</span><span class="p">:</span><span class="w"> </span><span class="l">node</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">affinity</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">nodeAffinity</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">requiredDuringSchedulingIgnoredDuringExecution</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">nodeSelectorTerms</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span>- <span class="nt">matchExpressions</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">kubernetes.io/os</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">In</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">values</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span>- <span class="l">linux</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">args</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- --<span class="l">ip-masq</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- --<span class="l">kube-subnet-mgr</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">command</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">/opt/bin/flanneld</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">env</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">POD_NAME</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">valueFrom</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">fieldRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">fieldPath</span><span class="p">:</span><span class="w"> </span><span class="l">metadata.name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">POD_NAMESPACE</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">valueFrom</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">fieldRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">fieldPath</span><span class="p">:</span><span class="w"> </span><span class="l">metadata.namespace</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">EVENT_QUEUE_DEPTH</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;5000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">docker.io/flannel/flannel:v0.24.0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">kube-flannel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">resources</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">requests</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">cpu</span><span class="p">:</span><span class="w"> </span><span class="l">100m</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">memory</span><span class="p">:</span><span class="w"> </span><span class="l">50Mi</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">securityContext</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">capabilities</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">add</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span>- <span class="l">NET_ADMIN</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span>- <span class="l">NET_RAW</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">privileged</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/run/flannel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">run</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/etc/kube-flannel/</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">flannel-cfg</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/run/xtables.lock</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xtables-lock</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">hostNetwork</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">initContainers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">args</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- -<span class="l">f</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">/flannel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">/opt/cni/bin/flannel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">command</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">cp</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">docker.io/flannel/flannel-cni-plugin:v1.2.0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">install-cni-plugin</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/opt/cni/bin</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">cni-plugin</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">args</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- -<span class="l">f</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">/etc/kube-flannel/cni-conf.json</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">/etc/cni/net.d/10-flannel.conflist</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">command</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">cp</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">docker.io/flannel/flannel:v0.24.0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">install-cni</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/etc/cni/net.d</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">cni</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/etc/kube-flannel/</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">flannel-cfg</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">priorityClassName</span><span class="p">:</span><span class="w"> </span><span class="l">system-node-critical</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">serviceAccountName</span><span class="p">:</span><span class="w"> </span><span class="l">flannel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">tolerations</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">effect</span><span class="p">:</span><span class="w"> </span><span class="l">NoSchedule</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">Exists</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">hostPath</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/run/flannel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">run</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">hostPath</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/opt/cni/bin</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">cni-plugin</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">hostPath</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/etc/cni/net.d</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">cni</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">configMap</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">kube-flannel-cfg</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">flannel-cfg</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">hostPath</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/run/xtables.lock</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">FileOrCreate</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xtables-lock</span></span></span></code></pre></div><h4 id="433-flannel-基于vxlan原理解析">4.3.3 Flannel 基于Vxlan原理解析</h4>
<p>下面的路由信息取自k8s-node0节点，它由该节点上的flanneld根据集群中各节点获得的子网信息生成。</p>
<div class="highlight" id="id-7"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-node1:~# route -n
</span></span><span class="line"><span class="cl">Kernel IP routing table
</span></span><span class="line"><span class="cl">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
</span></span><span class="line"><span class="cl">0.0.0.0         192.168.1.1     0.0.0.0         UG    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> eth0
</span></span><span class="line"><span class="cl">172.17.0.0      0.0.0.0         255.255.0.0     U     <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> docker0
</span></span><span class="line"><span class="cl">172.20.0.0      172.20.0.0      255.255.255.0   UG    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> flannel.1
</span></span><span class="line"><span class="cl">172.20.1.0      172.20.1.0      255.255.255.0   UG    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> flannel.1
</span></span><span class="line"><span class="cl">172.20.2.0      0.0.0.0         255.255.255.0   U     <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> cni0
</span></span><span class="line"><span class="cl">192.168.1.0     0.0.0.0         255.255.255.0   U     <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> eth0</span></span></code></pre></div><p>其中，172.20.0.0/24由k8s-master1使用，172.20.1.0/24由k8s-node2节点使用，172.20.2.0/24由k8s-node1节点使用</p>
<div class="highlight" id="id-8"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1">#k8s-master</span>
</span></span><span class="line"><span class="cl">root@k8s-master:~# cat /run/flannel/subnet.env
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_NETWORK</span><span class="o">=</span>172.20.0.0/16
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_SUBNET</span><span class="o">=</span>172.20.0.1/24
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_MTU</span><span class="o">=</span><span class="m">1450</span>
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_IPMASQ</span><span class="o">=</span><span class="nb">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#k8s-node1</span>
</span></span><span class="line"><span class="cl">root@k8s-node1:~# cat /run/flannel/subnet.env
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_NETWORK</span><span class="o">=</span>172.20.0.0/16
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_SUBNET</span><span class="o">=</span>172.20.2.1/24
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_MTU</span><span class="o">=</span><span class="m">1450</span>
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_IPMASQ</span><span class="o">=</span><span class="nb">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#k8s-node2</span>
</span></span><span class="line"><span class="cl">root@k8s-node2:~# cat /run/flannel/subnet.env
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_NETWORK</span><span class="o">=</span>172.20.0.0/16
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_SUBNET</span><span class="o">=</span>172.20.1.1/24
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_MTU</span><span class="o">=</span><span class="m">1450</span>
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_IPMASQ</span><span class="o">=</span>true</span></span></code></pre></div><p>这些路由条目恰恰反映了同节点Pod间通信时经由cni0虚拟网桥转发，而跨节点Pod间通信时，报文将经由当前节点（k8s-node01）的flannel.1隧道入口（VTEP设备）外发，隧道出口由“下一跳”信息指定，例如到达172.20.5.0/24网络的报文隧道出口是172.20.5.0指向的接口，它配置在k8s-node03的flannel.1接口之上，该接口正是k8s-node03上的隧道出入口（VTEP设备）。</p>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/2719436-20220221214951157-1309738775.png" srcset="https://cdn1.ryanxin.live/2719436-20220221214951157-1309738775.png, https://cdn1.ryanxin.live/2719436-20220221214951157-1309738775.png 1.5x, https://cdn1.ryanxin.live/2719436-20220221214951157-1309738775.png 2x" sizes="auto" data-title="img" data-alt="img" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>VXLAN网络将各VTEP设备作为同一个二层网络上的接口，这些接口设备组成一个虚拟的二层网络。</p>
<p>Pod-1发往Pod-4的IP报文将在流经其所在节点的flannel.1接口时封装成数据帧，源MAC是k8s-node01节点上的flannel.1接口的MAC地址，而目标MAC则是k8s-node02节点上flannel.1接口的MAC地址。</p>
<p>但Flannel并非依赖ARP进行MAC地址学习，而是由节点上的flanneld进程启动时将本地flannel.1接口IP与MAC地址的映射信息上报到etcd中，并由其他各节点上的flanneld来动态生成相应的解析记录。</p>
<p>下面的解析记录取自k8s-node01节点，它们分别指明了集群中的其他节点上的flannel.1接口各自对应的MAC地址，PERMANENT属性表明这些记录均永久有效。</p>
<div class="highlight" id="id-9"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-node1:~# ip neigh show <span class="p">|</span> awk <span class="s1">&#39;$3 == &#34;flannel.1&#34;{print $0}&#39;</span>
</span></span><span class="line"><span class="cl">172.20.0.0 dev flannel.1 lladdr fa:40:5f:2d:8e:40 PERMANENT
</span></span><span class="line"><span class="cl">172.20.1.0 dev flannel.1 lladdr 5e:b1:10:42:f7:bd PERMANENT</span></span></code></pre></div><p>VXLAN协议使用UDP报文封装隧道内层数据帧，Pod发出的报文经隧道入口flannel.1封装成数据帧，再由flanneld进程（客户端）封装成UDP报文，之后发往目标Pod对象所在节点的flanneld进程（服务端）。该UDP报文就是所谓的VXLAN隧道，它会在已经生成的帧报文之外再封装一组协议头部，如图10-15所示为VXLAN头部、外层UDP头部、外层IP头部和外层帧头部。</p>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/2719436-20220221215632736-823011711.png" srcset="https://cdn1.ryanxin.live/2719436-20220221215632736-823011711.png, https://cdn1.ryanxin.live/2719436-20220221215632736-823011711.png 1.5x, https://cdn1.ryanxin.live/2719436-20220221215632736-823011711.png 2x" sizes="auto" data-title="img" data-alt="img" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h4 id="434-flannel-基于vxlan通信流程">4.3.4 Flannel 基于Vxlan通信流程</h4>
<div class="highlight" id="id-10"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">1<span class="o">)</span> 源容器veth0向目标容器发送数据，根据容器内的默认路由，数据首先发送给宿主机的docker0网桥
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">2）宿主机docker0网桥接受到数据后，宿主机查询路由表，pod相关的路由都是交由flannel.1网卡，因此，将其转发给flannel.1虚拟网卡处理
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">3）flannel.1接受到数据后，查询etcd数据库，获取目标pod网段对应的目标宿主机地址、目标宿主机的flannel网卡的mac地址、vxlan vnid等信息。然后对数据进行udp封装如下：
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">udp头封装：
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">source</span> port &gt;1024，target port <span class="m">8472</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">udp内部封装：
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  vxlan封装：vxlan vnid等信息
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  original layer <span class="m">2</span> frame封装：source <span class="o">{</span>源 flannel.1网卡mac地址<span class="o">}</span> target<span class="o">{</span>目标flannel.1网卡的mac地址<span class="o">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">完成以上udp封装后，将数据转发给物理机的eth0网卡
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">4）宿主机eth0接收到来自flannel.1的udp包，还需要将其封装成正常的通信用的数据包，为它加上通用的ip头、二层头，这项工作在由linux内核来完成。
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">Ethernet Header的信息：
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">source:<span class="o">{</span>源宿主机机网卡的MAC地址<span class="o">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">target:<span class="o">{</span>目标宿主机网卡的MAC地址<span class="o">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">IP Header的信息：
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">source:<span class="o">{</span>源宿主机网卡的IP地址<span class="o">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">target:<span class="o">{</span>目标宿主机网卡的IP地址<span class="o">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">通过此次封装，一个真正可用的数据包就封装完成，可以通过物理网络传输了。
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">5）目标宿主机的eth0接收到数据后，对数据包进行拆封，拆到udp层后，将其转发给8472端口的flannel进程
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">6）目标宿主机端flannel拆除udp头、vxlan头，获取到内部的原始数据帧，在原始数据帧内部，解析出源容器ip、目标容器ip，重新封装成通用的数据包，查询路由表，转发给docker0网桥；
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">7）最后，docker0网桥将数据送达目标容器内的veth0网卡，完成容器之间的数据通信</span></span></code></pre></div><h3 id="44-directrouting-直接路由">4.4 DirectRouting 直接路由</h3>
<p>​      若集群过于庞大，则避免不了跨网段通信，或者既想使用VxLAN可以跨网段的特性，又想host-gw的高性能，我们可以设置为Directrouting，使其同网段的用host-gw，不同网段的自动使用VxLAN网络叠加。
我们也可以将flannel配置为VxLAN + Directrouting方式，若请求端和回应端在同网段，则使用直接路由模式，若不同网段，则自动降级为VxLAN模式。</p>
<p>在Kubernetes上的Flannel来说，修改kube-system名称空间下的<code>configmaps/kube-flannel-cfg</code>资源，为VXLAN后端添加DirectRouting子键，并设置其值为true即可。</p>
<p>k8s集群是使用kubeasz部署的，因此需要修改kubeasz中关于集群网路的配置并重新部署k8s集群</p>
<div class="highlight" id="id-11"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-deploy:~# vim /etc/kubeasz/clusters/k8s-test/config.yml 
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">FLANNEL_BACKEND: <span class="s2">&#34;vxlan&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#DIRECT_ROUTING: false</span>
</span></span><span class="line"><span class="cl">DIRECT_ROUTING: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">......</span></span></code></pre></div><p>节点上的路由规则也会相应发生变动，到达与本地节点位于同一二层网络中的其他节点，Pod子网的下一跳地址由对端flannel.1接口地址变为了宿主机物理接口的地址，本地用于发出报文的接口从flannel.1变成了本地的物理接口。</p>
<p>Pod与节点通常不在同一网络。Pod间的通信报文需要经由宿主机的物理接口发出，必然会经过iptables/netfilter的forward钩子，为了避免该类报文被防火墙拦截，Flannel必须为其设定必要的放行规则。本集群中的每个节点上iptables filter表的FORWARD链上都会生成如下两条转发规则，以确保由物理接口接收或发送的目标地址或源地址为172.20.0/16网络的所有报文能够正常通过。</p>
<div class="highlight" id="id-12"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-master1:~# iptables -nL
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">ACCEPT     all  --  172.20.0.0/16        anywhere            
</span></span><span class="line"><span class="cl">ACCEPT     all  --  anywhere             172.20.0.0/16  
</span></span><span class="line"><span class="cl">......</span></span></code></pre></div><h4 id="441-directrouting案例">4.4.1 DirectRouting案例</h4>
<p>创建2个pod</p>
<div class="highlight" id="id-13"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-deploy:/etc/kubeasz# kubectl run testpod-1 --image<span class="o">=</span>ikubernetes/demoapp:v1.0
</span></span><span class="line"><span class="cl">pod/testpod-1 created
</span></span><span class="line"><span class="cl">root@k8s-deploy:/etc/kubeasz# kubectl run testpod-2 --image<span class="o">=</span>ikubernetes/demoapp:v1.0
</span></span><span class="line"><span class="cl">pod/testpod-2 created
</span></span><span class="line"><span class="cl">root@k8s-deploy:/etc/kubeasz# kubectl get pod -o wide
</span></span><span class="line"><span class="cl">NAME        READY   STATUS    RESTARTS   AGE   IP            NODE            NOMINATED NODE   READINESS GATES
</span></span><span class="line"><span class="cl">testpod-1   1/1     Running   <span class="m">0</span>          40s   172.20.1.6    192.168.1.103   &lt;none&gt;           &lt;none&gt;
</span></span><span class="line"><span class="cl">testpod-2   1/1     Running   <span class="m">0</span>          31s   172.20.2.10   192.168.1.102   &lt;none&gt;           &lt;none&gt;</span></span></code></pre></div><p>进入testpod-1</p>
<div class="highlight" id="id-14"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">oot@k8s-deploy:/etc/kubeasz# kubectl <span class="nb">exec</span> -it testpod-1 -- sh
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@testpod-1 /<span class="o">]</span><span class="c1"># traceroute 172.20.2.10</span>
</span></span><span class="line"><span class="cl">traceroute to 172.20.2.10 <span class="o">(</span>172.20.2.10<span class="o">)</span>, <span class="m">30</span> hops max, <span class="m">46</span> byte packets
</span></span><span class="line"><span class="cl"> <span class="m">1</span>  172.20.1.1 <span class="o">(</span>172.20.1.1<span class="o">)</span>  0.004 ms  0.002 ms  0.001 ms
</span></span><span class="line"><span class="cl"> <span class="m">2</span>  192.168.1.102 <span class="o">(</span>192.168.1.102<span class="o">)</span>  0.336 ms  0.121 ms  0.095 ms
</span></span><span class="line"><span class="cl"> <span class="m">3</span>  172.20.2.10 <span class="o">(</span>172.20.2.10<span class="o">)</span>  0.140 ms  0.239 ms  0.123 ms
</span></span><span class="line"><span class="cl"><span class="c1">#testpod-1访问testpod-2时，不在转发非flannel,而是直接转发给testpod-2所在的node节点</span></span></span></code></pre></div><p>这种路由规则无法表达跨二层网络的节点上Pod间通信的诉求，因为到达目标网络（某Pod子网）的下一跳地址无法指向另一个网段的节点地址。因而，集群中的每个节点上依然保留有VXLAN隧道相关的flannel.1设备，以支持那些跨IP网络的节点上的Pod间通信。</p>
<p>以k8s-node1为例子</p>
<div class="highlight" id="id-15"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-node1:~# ip a <span class="p">|</span> grep flannel.1
</span></span><span class="line"><span class="cl">5: flannel.1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1450</span> qdisc noqueue state UNKNOWN group default 
</span></span><span class="line"><span class="cl">    inet 172.20.2.0/32 brd 172.20.2.0 scope global flannel.1</span></span></code></pre></div><h3 id="45-host-gw">4.5 host-gw</h3>
<p>Flannel的host-gw后端通过添加必要的路由信息，并使用节点的二层网络直接发送Pod间的通信报文，其工作方式类似于VXLAN后端中的直接路由功能，但不包括该后端支持的隧道转发能力，这意味着host-gw后端要求各节点必须位于同一个二层网络中。其工作模型示意图如下图所示。因完全不会用到VXLAN隧道，所以使用了host-gw后端的Flannel网络也就无须用到VTEP设备flannel.1。</p>
<p><strong>注意：</strong></p>
<p><strong>直接路由仅node节点在同一网段，不能跨网段。</strong></p>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/2719436-20220221225638132-1663668842.png" srcset="https://cdn1.ryanxin.live/2719436-20220221225638132-1663668842.png, https://cdn1.ryanxin.live/2719436-20220221225638132-1663668842.png 1.5x, https://cdn1.ryanxin.live/2719436-20220221225638132-1663668842.png 2x" sizes="auto" data-title="img" data-alt="img" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>host-gw后端没有多余的配置参数，直接设定配置文件中的<code>Backend.Type</code>键的值为host-gw关键字即可。同样，直接修改kube-system名称空间中的<code>configmaps/kube-flannel.cfg</code>配置文件，类似下面配置示例中的内容即可。</p>
<div class="highlight" id="id-16"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="err">net-conf.json:</span> <span class="err">|</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Network&#34;</span><span class="p">:</span> <span class="s2">&#34;172.20.0.0/16&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Backend&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;Type&#34;</span><span class="p">:</span> <span class="s2">&#34;host-gw&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></div><p>配置完成后，集群中的各节点会生成类似VXLAN后端的DirectRouting路由及iptables规则，以转发Pod网络的通信报文，它完全省去了隧道转发模式的额外开销。代价是，对于非同一个二层网络的报文转发，host-gw完全无能为力。相对而言，VXLAN的DirectRouting后端转发模式兼具VXLAN后端和host-gw后端的优势，既保证了传输性能，又具备跨二层网络转发报文的能力。</p>
<p>像host-gw或VXLAN后端的直接路由模式这种使用静态路由实现Pod间通信报文的转发，虽然较之VXLAN Overlay网络有着更低的资源开销和更好的性能表现，但当Kubernetes集群规模较大时，其路由信息的规模也将变得庞大且不易维护。相比较来说，Calico通过BGP协议自动维护路由条目，较之Flannel以etcd为总线以上报、查询和更新配置的工作逻辑更加高效和易于维护，因而更适用于大型网络。</p>
<p>Flannel自身并不具备为Pod网络实施网络策略以实现其网络通信控制的能力，它只能借助Calico这类支持网络策略的插件实现该功能，独立的项目Calico正为此目的而设立。</p>
<h4 id="451-host-gw案例">4.5.1 host-gw案例</h4>
<div class="highlight" id="id-17"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-deploy:~# vim /etc/kubeasz/clusters/k8s-test/config.yml 
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl"><span class="c1">#FLANNEL_BACKEND: &#34;vxlan&#34;</span>
</span></span><span class="line"><span class="cl">FLANNEL_BACKEND: <span class="s2">&#34;host-gw&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#DIRECT_ROUTING: false</span>
</span></span><span class="line"><span class="cl"><span class="c1">#DIRECT_ROUTING: true</span>
</span></span><span class="line"><span class="cl">......</span></span></code></pre></div><p>以k8s-node1为例</p>
<div class="highlight" id="id-18"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-node1:~# ip route
</span></span><span class="line"><span class="cl">default via 192.168.1.1 dev eth0 proto static 
</span></span><span class="line"><span class="cl">172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 
</span></span><span class="line"><span class="cl">172.20.0.0/24 via 192.168.1.101 dev eth0 
</span></span><span class="line"><span class="cl">172.20.1.0/24 via 192.168.1.103 dev eth0 
</span></span><span class="line"><span class="cl">172.20.2.0/24 dev cni0 proto kernel scope link src 172.20.2.1 
</span></span><span class="line"><span class="cl">192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.102
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">root@k8s-node1:~# ip a  <span class="p">|</span> grep flannel
</span></span><span class="line"><span class="cl">root@k8s-node1:~#
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#无flannel设备</span></span></span></code></pre></div><h2 id="5calico网络插件">5.Calico网络插件</h2>
<p>官网：<a href="https://www.projectcalico.org/"target="_blank" rel="external nofollow noopener noreferrer">https://www.projectcalico.org</a></p>
<p>Calico是一个纯三层的虚拟网络解决方案，它把每个节点都当作虚拟路由器（vRouter），并把每个节点上的Pod都当作是“节点路由器”后的一个终端设备并为其分配一个IP地址。各节点路由器通过BGP协议学习生成路由规则，从而实现不同节点上Pod间的互联互通。</p>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/2719436-20220221230639689-1947384991.png" srcset="https://cdn1.ryanxin.live/2719436-20220221230639689-1947384991.png, https://cdn1.ryanxin.live/2719436-20220221230639689-1947384991.png 1.5x, https://cdn1.ryanxin.live/2719436-20220221230639689-1947384991.png 2x" sizes="auto" data-title="img" data-alt="img" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>BGP是互联网上一个核心的去中心化自治路由协议，它通过维护IP路由表或“前缀”表来实现自治系统（AS）之间的可达性，通常作为大规模数据中心维护不同的自治系统之间路由信息的矢量路由协议。Linux内核原生支持BGP，因而我们可轻易把一台Linux主机配置成为边界网关。 Calico把Kubernetes集群环境中的每个节点上的Pod所组成的网络视为一个自治系统，而每个节点也就自然由各自的Pod对象组成虚拟网络，进而形成自治系统的边界网关。各节点间通过BGP协议交换路由信息并生成路由规则。但考虑到并非所有网络都能支持BGP，而且BGP路由模型要求所有节点必须要位于同一个二层网络，所以Calico还支持基于IPIP和VXLAN的Overlay网络模型，它们的工作模式与Flannel的VXLAN和IPIP模型并无显著不同。 类似Flannel在VXLAN后端启用DirectRouting时的网络模型，Calico也支持混合使用路由和Overlay网络模型，BGP路由模型用于二层网络的高性能通信，IP-IP或VXLAN用于跨子网的节点间报文转发，如下所示。IP-IP协议包头非常小，理论上它的速度要比VXLAN稍快一点，但安全性更差。</p>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/2719436-20220221230839845-46907500.png" srcset="https://cdn1.ryanxin.live/2719436-20220221230839845-46907500.png, https://cdn1.ryanxin.live/2719436-20220221230839845-46907500.png 1.5x, https://cdn1.ryanxin.live/2719436-20220221230839845-46907500.png 2x" sizes="auto" data-title="img" data-alt="img" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>Calico网络提供的在线部署清单中默认使用的是IPIP隧道网络，而非BGP或者混合模型，因为它假设节点的底层网络不支持BGP协议。明确需要使用BGP或混合模型时，需要事先修改calico的yaml清单文件，按需修改后方可部署在Kubernetes集群之上。</p>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/2719436-20220221230925125-178311608.png" srcset="https://cdn1.ryanxin.live/2719436-20220221230925125-178311608.png, https://cdn1.ryanxin.live/2719436-20220221230925125-178311608.png 1.5x, https://cdn1.ryanxin.live/2719436-20220221230925125-178311608.png 2x" sizes="auto" data-title="img" data-alt="img" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/2719436-20220221230929809-222558607.png" srcset="https://cdn1.ryanxin.live/2719436-20220221230929809-222558607.png, https://cdn1.ryanxin.live/2719436-20220221230929809-222558607.png 1.5x, https://cdn1.ryanxin.live/2719436-20220221230929809-222558607.png 2x" sizes="auto" data-title="img" data-alt="img" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>BGP模式下的Calico所承载的各Pod资源直接基于vRouter经由基础网络进行互联，它非叠加、无隧道、不使用VRF表，也不依赖于NAT，因此每个工作负载都可以直接配置使用公网IP接入互联网，当然，也可以按需使用网络策略控制它的网络连通性。</p>
<p>Calico的系统组件主要有Felix、BGP路由反射器、编排系统插件、BIRD和etcd存储系统等。</p>
<p>（1）Felix Felix是运行于各节点上守护进程，它主要负责完成接口管理、路由规划、ACL规划和状态报告几个核心任务，从而为各端点（VM或Container）生成连接机制。 1）接口管理，负责创建网络接口、生成必要信息并送往内核，以确保内核能正确处理各端点的流量，尤其是要确保目标节点MAC能响应当前节点上各工作负载的MAC地址的ARP请求，以及为Felix管理的接口打开转发功能。另外，接口管理还要监控各接口的变动以确保规则能得到正确应用。 2）路由规划，负责为当前节点上运行的各端点在内核FIB（Forwarding Information Base）中生成路由信息，以保证到达当前节点的报文可正确转发给端点。 3）ACL规划，负责在Linux内核中生成ACL，实现仅放行端点间的合规流量，并确保流量不能绕过Calico等安全措施。 4）状态报告，负责提供网络健康状态的相关数据，尤其是报告由Felix管理的节点上的错误和问题。这些报告数据会存储在etcd，供其他组件或网络管理员使用。</p>
<p>简单理解为：运行在每一台node节点上，主要功能是维护路由规则、汇报当前节点状态以确保pod的跨主机通信。</p>
<p>（2）编排系统插件 编排系统插件的主要功能是将Calico整合进所在的编排系统中，例如Kubernetes或OpenStack等。它主要负责完成API转换，从而让管理员和用户能够无差别地使用Calico的网络功能。换句话说，编排系统通常有自己的网络管理API，相应的插件要负责将对这些API的调用转换为Calico的数据模型，并存储到Calico的存储系统中。因而，编排插件的具体实现依赖于底层编排系统，不同的编排系统有各自专用的插件。</p>
<p>（3）etcd存储系统 利用etcd，Calico网络可实现为有明确状态（正常或故障）的系统，且易于通过扩展应对访问压力的提升，避免自身成为系统瓶颈。另外，etcd也是Calico各组件的通信总线。</p>
<p>（4）BGP客户端 Calico要求在每个运行着Felix的节点上同时运行一个称为BIRD的守护进程，它是BGP协议的客户端，负责将Felix生成的路由信息载入内核并通告给整个网络中。</p>
<p>BGP Client运行在每一台node节点，负责监听node节点上由felix生成的路由信息，然后通过BGP协议广播至其他剩余的node节点，从而相互学习路由实现pod通信。</p>
<p>（5）BGP路由反射器 Calico在每一个计算节点利用Linux内核实现了一个高效的vRouter（虚拟路由器）进行报文转发。每个vRouter通过BGP协议将自身所属节点运行的Pod资源的IP地址信息，基于节点上的专用代理程序（Felix）生成路由规则向整个Calico网络内传播。尽管小规模部署能够直接使用BGP网格模型，但随着节点数量（假设为N）的增加，这些连接的数量就会以N2的规模快速增长，从而给集群网络带来巨大的压力。因此，一般建议大规模的节点网络使用BGP路由反射器进行路由学习，BGP的点到点通信也就转为与中心点的单路通信模型。另外，出于冗余考虑，生产实践中应该部署多个BGP路由反射器。而对于Calico来说，BGP客户端程序除了作为客户端使用外，也可以配置为路由反射器。</p>
<p>Route Reflector：集中式的路由反射器，calico v3.3开始支持，当calico BGP客户端将路由从其FIB（Forward Information DataBase，转发信息库）通告到Route Reflector时，Route Reflector会将这些路由通告给部署集群中的其他节点，Route Reflector专门用于管理BGP网络路由规则，不会产生pod数据通信。</p>
<p>注意：</p>
<p>calico默认工作模式为BGP的node-to-node mesh,如果需要使用Route Reflector需要进行相关配置。</p>
<p><a href="https://docs.projectcalico.org/v3.4/usage/routereflector"target="_blank" rel="external nofollow noopener noreferrer">https://docs.projectcalico.org/v3.4/usage/routereflector</a></p>
<p><a href="https://docs.projectcalico.org/v3.2/usage/routereflector/calico-routerreflector"target="_blank" rel="external nofollow noopener noreferrer">https://docs.projectcalico.org/v3.2/usage/routereflector/calico-routerreflector</a></p>
<h3 id="51-calico-工作原理">5.1 Calico 工作原理</h3>
<p>Calico把每个操作系统的协议栈认为是一个路由器，然后把所有的容器认为是连在这个路由器上的网络终端，在路由器之间跑标准的路由协议——BGP的协议，然后让它们自己去学习这个网络拓扑该如何转发。所以Calico方案其实是一个纯三层的方案，也就是说让每台机器的协议栈的三层去确保两个容器，跨主机容器之间的三层连通性。</p>
<p>对于控制平面，它每个节点上会运行两个主要的程序，一个是Felix，它会监听ECTD中心的存储，从它获取事件，比如说用户在这台机器上加了一个IP，或者是分配了一个容器等。接着会在这台机器上创建出一个容器，并将其网卡、IP、MAC都设置好，然后在内核的路由表里面写一条，注明这个IP应该到这张网卡。绿色部分是一个标准的路由程序，它会从内核里面获取哪一些IP的路由发生了变化，然后通过标准BGP的路由协议扩散到整个其他的宿主机上，让外界都知道这个IP在这里，你们路由的时候得到这里来。</p>
<p>由于Calico是一种纯三层的实现，因此可以避免与二层方案相关的数据包封装的操作，中间没有任何的NAT，没有任何的overlay，所以它的转发效率可能是所有方案中最高的，因为它的包直接走原生TCP/IP的协议栈，它的隔离也因为这个栈而变得好做。因为TCP/IP的协议栈提供了一整套的防火墙的规则，所以它可以通过IPTABLES的规则达到比较复杂的隔离逻辑。</p>
<h3 id="52-node-to-node-mesh模式">5.2 node-to-node mesh模式</h3>
<p>全互联模式 每一个BGP Speaker都需要和其他BGP Speaker建立BGP连接，这样BGP连接总数就是N*（N-1），如果数量过大会消耗大量连接。如果集群数量超过100台官方不建议使用此种模式。</p>
<h4 id="521--calico开启ipip模式">5.2.1  Calico开启IPIP模式</h4>
<p>calico是使用node-to-node mesh的方式要维护路由规则，及每个node节点上都有n(n-1)条路哟规则，n为node的节点数量。</p>
<p>以k8s-node1为例来验证路由信息</p>
<p>calico 2.x 版本默认使用etcd v2 API</p>
<p>calico 3.x 版本默认使用etcd v3 API</p>
<div class="highlight" id="id-19"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-node1:~# calicoctl node status
</span></span><span class="line"><span class="cl">Calico process is running.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">IPv4 BGP status
</span></span><span class="line"><span class="cl">+---------------+-------------------+-------+----------+-------------+
</span></span><span class="line"><span class="cl"><span class="p">|</span> PEER ADDRESS  <span class="p">|</span>     PEER TYPE     <span class="p">|</span> STATE <span class="p">|</span>  SINCE   <span class="p">|</span>    INFO     <span class="p">|</span>
</span></span><span class="line"><span class="cl">+---------------+-------------------+-------+----------+-------------+
</span></span><span class="line"><span class="cl"><span class="p">|</span> 192.168.1.101 <span class="p">|</span> node-to-node mesh <span class="p">|</span> up    <span class="p">|</span> 15:25:25 <span class="p">|</span> Established <span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span> 192.168.1.103 <span class="p">|</span> node-to-node mesh <span class="p">|</span> up    <span class="p">|</span> 15:25:26 <span class="p">|</span> Established <span class="p">|</span>
</span></span><span class="line"><span class="cl">+---------------+-------------------+-------+----------+-------------+
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">IPv6 BGP status
</span></span><span class="line"><span class="cl">No IPv6 peers found.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#k8s-node01所有的master和node节点都建立了BGP邻居关系</span></span></span></code></pre></div><p>开启IPIP的路由状态</p>
<p>运行4个pod</p>
<div class="highlight" id="id-20"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-deploy:/etc/kubeasz# kubectl run testpod-1 --image<span class="o">=</span>ikubernetes/demoapp:v1.0
</span></span><span class="line"><span class="cl">pod/testpod-1 created
</span></span><span class="line"><span class="cl">root@k8s-deploy:/etc/kubeasz# kubectl run testpod-2 --image<span class="o">=</span>ikubernetes/demoapp:v1.0
</span></span><span class="line"><span class="cl">pod/testpod-2 created
</span></span><span class="line"><span class="cl">root@k8s-deploy:/etc/kubeasz# kubectl run testpod-3 --image<span class="o">=</span>ikubernetes/demoapp:v1.0
</span></span><span class="line"><span class="cl">pod/testpod-3 created
</span></span><span class="line"><span class="cl">root@k8s-deploy:/etc/kubeasz# kubectl run testpod-4 --image<span class="o">=</span>ikubernetes/demoapp:v1.0
</span></span><span class="line"><span class="cl">pod/testpod-4 created
</span></span><span class="line"><span class="cl">root@k8s-deploy:/etc/kubeasz# kubectl get pod -A -o wide
</span></span><span class="line"><span class="cl">NAMESPACE     NAME                                       READY   STATUS    RESTARTS   AGE    IP               NODE            NOMINATED NODE   READINESS GATES
</span></span><span class="line"><span class="cl">default       testpod-1                                  1/1     Running   <span class="m">2</span>          69m    172.20.169.129   192.168.1.103   &lt;none&gt;           &lt;none&gt;
</span></span><span class="line"><span class="cl">default       testpod-2                                  1/1     Running   <span class="m">2</span>          69m    172.20.36.66     192.168.1.102   &lt;none&gt;           &lt;none&gt;
</span></span><span class="line"><span class="cl">default       testpod-3                                  1/1     Running   <span class="m">0</span>          5s     172.20.36.67     192.168.1.102   &lt;none&gt;           &lt;none&gt;
</span></span><span class="line"><span class="cl">default       testpod-4                                  1/1     Running   <span class="m">0</span>          2s     172.20.169.130   192.168.1.103   &lt;none&gt;           &lt;none&gt;</span></span></code></pre></div><p>查看k8s-node1的路由信息</p>
<div class="highlight" id="id-21"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-node1:~# route -n
</span></span><span class="line"><span class="cl">Kernel IP routing table
</span></span><span class="line"><span class="cl">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
</span></span><span class="line"><span class="cl">0.0.0.0         192.168.1.1     0.0.0.0         UG    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> eth0
</span></span><span class="line"><span class="cl">172.17.0.0      0.0.0.0         255.255.0.0     U     <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> docker0
</span></span><span class="line"><span class="cl">172.20.36.64    0.0.0.0         255.255.255.192 U     <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> *
</span></span><span class="line"><span class="cl">172.20.36.65    0.0.0.0         255.255.255.255 UH    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> cali146f692ec0d
</span></span><span class="line"><span class="cl">172.20.36.66    0.0.0.0         255.255.255.255 UH    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> cali3d1e6ac0b31
</span></span><span class="line"><span class="cl">172.20.36.67    0.0.0.0         255.255.255.255 UH    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> cali4a41f53597d
</span></span><span class="line"><span class="cl">172.20.169.128  192.168.1.103   255.255.255.192 UG    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> tunl0
</span></span><span class="line"><span class="cl">172.20.235.192  192.168.1.101   255.255.255.192 UG    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> tunl0
</span></span><span class="line"><span class="cl">192.168.1.0     0.0.0.0         255.255.255.0   U     <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> eth0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">root@k8s-node1:~# ip route
</span></span><span class="line"><span class="cl">default via 192.168.1.1 dev eth0 proto static 
</span></span><span class="line"><span class="cl">172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 
</span></span><span class="line"><span class="cl">blackhole 172.20.36.64/26 proto bird 
</span></span><span class="line"><span class="cl">172.20.36.65 dev cali146f692ec0d scope link 
</span></span><span class="line"><span class="cl">172.20.36.66 dev cali3d1e6ac0b31 scope link 
</span></span><span class="line"><span class="cl">172.20.36.67 dev cali4a41f53597d scope link 
</span></span><span class="line"><span class="cl">172.20.169.128/26 via 192.168.1.103 dev tunl0 proto bird onlink 
</span></span><span class="line"><span class="cl">172.20.235.192/26 via 192.168.1.101 dev tunl0 proto bird onlink 
</span></span><span class="line"><span class="cl">192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.102
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#1、k8s-node1上访问本地容器走cali3d1e6ac0b31接口，Calico并不会为容器在主机上使用网桥，而是仅为每个容器生成一对veth设备，留在主机上的那一端会在主机上生成目标地址，作为当前容器的路由条目。</span>
</span></span><span class="line"><span class="cl"><span class="c1">#2、k8s-node01上需要跨主机访问时，走tunl0隧道</span></span></span></code></pre></div><p><img loading="lazy" src="https://cdn1.ryanxin.live/2719436-20220221233720026-674862605.png" srcset="https://cdn1.ryanxin.live/2719436-20220221233720026-674862605.png, https://cdn1.ryanxin.live/2719436-20220221233720026-674862605.png 1.5x, https://cdn1.ryanxin.live/2719436-20220221233720026-674862605.png 2x" sizes="auto" data-title="img" data-alt="img" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p><img loading="lazy" src="https://cdn1.ryanxin.live/2719436-20220221233724641-829726378.png" srcset="https://cdn1.ryanxin.live/2719436-20220221233724641-829726378.png, https://cdn1.ryanxin.live/2719436-20220221233724641-829726378.png 1.5x, https://cdn1.ryanxin.live/2719436-20220221233724641-829726378.png 2x" sizes="auto" data-title="img" data-alt="img" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>Calico使用BGP（Border Gateway Protocol）协议在主机集群中自动分发和学习路由信息。与Flannel不同的是，Calico并不会为容器在主机上使用网桥，而是仅为每个容器生成一对veth设备，留在主机上的那一端会在主机上生成目标地址，作为当前容器的路由条目。</p>
<p>当访问同一个node的不同pod时，node节点会查询路由表把报文发往相应的calixxx目标地址；当访问不同node上的pod时，node会把数据包发往tunl0，再根据etcd中的保存的路由信息来转发。</p>
<div class="highlight" id="id-22"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-node1:~# route -n
</span></span><span class="line"><span class="cl">Kernel IP routing table
</span></span><span class="line"><span class="cl">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
</span></span><span class="line"><span class="cl">0.0.0.0         192.168.1.1     0.0.0.0         UG    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> eth0
</span></span><span class="line"><span class="cl">172.17.0.0      0.0.0.0         255.255.0.0     U     <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> docker0
</span></span><span class="line"><span class="cl">172.20.36.64    0.0.0.0         255.255.255.192 U     <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> *
</span></span><span class="line"><span class="cl">172.20.36.65    0.0.0.0         255.255.255.255 UH    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> cali146f692ec0d   <span class="c1">#本地容器接口</span>
</span></span><span class="line"><span class="cl">172.20.36.66    0.0.0.0         255.255.255.255 UH    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> cali3d1e6ac0b31    <span class="c1">#本地容器接口</span>
</span></span><span class="line"><span class="cl">172.20.36.67    0.0.0.0         255.255.255.255 UH    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> cali4a41f53597d   <span class="c1">#本地容器接口</span>
</span></span><span class="line"><span class="cl">172.20.169.128  192.168.1.103   255.255.255.192 UG    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> tunl0   <span class="c1">#隧道接口</span>
</span></span><span class="line"><span class="cl">172.20.235.192  192.168.1.101   255.255.255.192 UG    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> tunl0   <span class="c1">#隧道接口</span>
</span></span><span class="line"><span class="cl">192.168.1.0     0.0.0.0         255.255.255.0   U     <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> eth0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kubectl run testpod-1 --image<span class="o">=</span>ikubernetes/demoapp:v1.0
</span></span><span class="line"><span class="cl">kubectl run testpod-2 --image<span class="o">=</span>ikubernetes/demoapp:v1.0
</span></span><span class="line"><span class="cl">kubectl run testpod-3 --image<span class="o">=</span>ikubernetes/demoapp:v1.0
</span></span><span class="line"><span class="cl">kubectl run testpod-4 --image<span class="o">=</span>ikubernetes/demoapp:v1.0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">root@k8s-deploy:/etc/kubeasz# kubectl get pod -A -o wide
</span></span><span class="line"><span class="cl">NAMESPACE     NAME                                       READY   STATUS    RESTARTS   AGE    IP               NODE            NOMINATED NODE   READINESS GATES
</span></span><span class="line"><span class="cl">default       testpod-1                                  1/1     Running   <span class="m">2</span>          69m    172.20.169.129   192.168.1.103   &lt;none&gt;           &lt;none&gt;
</span></span><span class="line"><span class="cl">default       testpod-2                                  1/1     Running   <span class="m">2</span>          69m    172.20.36.66     192.168.1.102   &lt;none&gt;           &lt;none&gt;
</span></span><span class="line"><span class="cl">default       testpod-3                                  1/1     Running   <span class="m">0</span>          5s     172.20.36.67     192.168.1.102   &lt;none&gt;           &lt;none&gt;
</span></span><span class="line"><span class="cl">default       testpod-4                                  1/1     Running   <span class="m">0</span>          2s     172.20.169.130   192.168.1.103   &lt;none&gt;           &lt;none&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#测试在同一个node下pod的访问，k8s-node01上有2个pod，testpod-2和testpod-3</span>
</span></span><span class="line"><span class="cl">root@k8s-deploy:/etc/kubeasz# kubectl <span class="nb">exec</span> -it testpod-2 -- sh
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@testpod-2 /<span class="o">]</span><span class="c1"># traceroute 172.20.36.67</span>
</span></span><span class="line"><span class="cl">traceroute to 172.20.36.67 <span class="o">(</span>172.20.36.67<span class="o">)</span>, <span class="m">30</span> hops max, <span class="m">46</span> byte packets
</span></span><span class="line"><span class="cl"> <span class="m">1</span>  192.168.1.102 <span class="o">(</span>192.168.1.102<span class="o">)</span>  0.004 ms  0.005 ms  0.002 ms
</span></span><span class="line"><span class="cl"> <span class="m">2</span>  172.20.36.67 <span class="o">(</span>172.20.36.67<span class="o">)</span>  0.001 ms  0.003 ms  0.001 ms
</span></span><span class="line"><span class="cl"><span class="c1">#1、数据包从testpod-2出到达Veth Pair另一端（宿主机上，以cali前缀开头cali3d1e6ac0b31）</span>
</span></span><span class="line"><span class="cl"><span class="c1">#2、宿主机根据路由规则，将数据包转发给下一跳（网关）</span>
</span></span><span class="line"><span class="cl"><span class="c1">#3、发现下一跳为自己的cali4a41f53597d，直接转发数据包给cali4a41f53597d，到达test-pod3</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#测试在不在同一个node下pod的访问，testpod-2和testpod-4</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@testpod-2 /<span class="o">]</span><span class="c1"># traceroute 172.20.169.130</span>
</span></span><span class="line"><span class="cl">traceroute to 172.20.169.130 <span class="o">(</span>172.20.169.130<span class="o">)</span>, <span class="m">30</span> hops max, <span class="m">46</span> byte packets
</span></span><span class="line"><span class="cl"> <span class="m">1</span>  192.168.1.102 <span class="o">(</span>192.168.1.102<span class="o">)</span>  0.004 ms  0.003 ms  0.002 ms
</span></span><span class="line"><span class="cl"> <span class="m">2</span>  172.20.169.128 <span class="o">(</span>172.20.169.128<span class="o">)</span>  0.268 ms  0.082 ms  0.163 ms   <span class="c1">#走的tunl0隧道</span>
</span></span><span class="line"><span class="cl"> <span class="m">3</span>  172.20.169.130 <span class="o">(</span>172.20.169.130<span class="o">)</span>  0.191 ms  0.207 ms  0.153 ms
</span></span><span class="line"><span class="cl"><span class="c1">#1、数据包从 testpod-2 出到达Veth Pair另一端（宿主机上，以cali前缀开头cali3d1e6ac0b31）</span>
</span></span><span class="line"><span class="cl"><span class="c1">#2、宿主机根据路由规则，将数据包转发给下一跳（网关）</span>
</span></span><span class="line"><span class="cl"><span class="c1">#3、到达 Node3，根据路由规则将数据包转发给 cali 设备，从而到达 testpod-3。</span></span></span></code></pre></div><p>IPIP就是把一个IP数据包又套在一个IP包里，即把 IP 层封装到 IP 层的一个 tunnel，看起来似乎是浪费，实则不然。它的作用其实基本上就相当于一个基于IP层的网桥！一般来说，普通的网桥是基于mac层的，根本不需 IP，而这个 ipip 则是通过两端的路由做一个 tunnel，把两个本来不通的网络通过点对点连接起来。ipip 的源代码在内核 net/ipv4/ipip.c 中可以找到。</p>
<h4 id="522--calico关闭ipip模式">5.2.2  Calico关闭IPIP模式</h4>
<p>与Flannel的host-gw的模式相似，后端通过添加必要的路由信息，并使用节点的二层网络直接发送Pod间的通信报文，同时也跟host-gw一样不支持跨网段。</p>
<p>Calico关闭IPIP模式将不会有tunl0隧道，pod之间的访问全靠路由。</p>
<div class="highlight" id="id-23"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-deploy:~# vim /etc/kubeasz/clusters/k8s-test/config.yml 
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl"><span class="c1"># [calico]设置 CALICO_IPV4POOL_IPIP=“off”,可以提高网络性能，条件限制详见 docs/setup/calico.md</span>
</span></span><span class="line"><span class="cl"><span class="c1">#CALICO_IPV4POOL_IPIP: &#34;Always&#34;</span>
</span></span><span class="line"><span class="cl">CALICO_IPV4POOL_IPIP: <span class="s2">&#34;off&#34;</span>
</span></span><span class="line"><span class="cl">......</span></span></code></pre></div><p>创建4个pod</p>
<div class="highlight" id="id-24"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">kubectl run testpod-1 --image<span class="o">=</span>ikubernetes/demoapp:v1.0
</span></span><span class="line"><span class="cl">kubectl run testpod-2 --image<span class="o">=</span>ikubernetes/demoapp:v1.0
</span></span><span class="line"><span class="cl">kubectl run testpod-3 --image<span class="o">=</span>ikubernetes/demoapp:v1.0
</span></span><span class="line"><span class="cl">kubectl run testpod-4 --image<span class="o">=</span>ikubernetes/demoapp:v1.0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">root@k8s-deploy:/etc/kubeasz# kubectl get pod -o wide
</span></span><span class="line"><span class="cl">NAME        READY   STATUS    RESTARTS   AGE   IP               NODE            NOMINATED NODE   READINESS GATES
</span></span><span class="line"><span class="cl">testpod-1   1/1     Running   <span class="m">3</span>          97m   172.20.169.132   192.168.1.103   &lt;none&gt;           &lt;none&gt;
</span></span><span class="line"><span class="cl">testpod-2   1/1     Running   <span class="m">3</span>          96m   172.20.36.69     192.168.1.102   &lt;none&gt;           &lt;none&gt;
</span></span><span class="line"><span class="cl">testpod-3   1/1     Running   <span class="m">1</span>          27m   172.20.36.68     192.168.1.102   &lt;none&gt;           &lt;none&gt;
</span></span><span class="line"><span class="cl">testpod-4   1/1     Running   <span class="m">1</span>          27m   172.20.169.131   192.168.1.103   &lt;none&gt;           &lt;none&gt;</span></span></code></pre></div><p>查看k8s-node1上的路由信息</p>
<div class="highlight" id="id-25"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@k8s-node1:~# route -n
</span></span><span class="line"><span class="cl">Kernel IP routing table
</span></span><span class="line"><span class="cl">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
</span></span><span class="line"><span class="cl">0.0.0.0         192.168.1.1     0.0.0.0         UG    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> eth0
</span></span><span class="line"><span class="cl">172.17.0.0      0.0.0.0         255.255.0.0     U     <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> docker0
</span></span><span class="line"><span class="cl">172.20.36.64    0.0.0.0         255.255.255.192 U     <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> *
</span></span><span class="line"><span class="cl">172.20.36.68    0.0.0.0         255.255.255.255 UH    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> cali4a41f53597d
</span></span><span class="line"><span class="cl">172.20.36.69    0.0.0.0         255.255.255.255 UH    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> cali3d1e6ac0b31
</span></span><span class="line"><span class="cl">172.20.36.70    0.0.0.0         255.255.255.255 UH    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> cali146f692ec0d
</span></span><span class="line"><span class="cl">172.20.169.128  192.168.1.103   255.255.255.192 UG    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> eth0
</span></span><span class="line"><span class="cl">172.20.235.192  192.168.1.101   255.255.255.192 UG    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> eth0
</span></span><span class="line"><span class="cl">192.168.1.0     0.0.0.0         255.255.255.0   U     <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> eth0</span></span></code></pre></div><p>没有tunl0隧道接口</p>
<h3 id="53-route-reflector-模式rr路由反射">5.3 Route Reflector 模式（RR路由反射）</h3>
<p>设置方法请参考官方链接 <a href="https://docs.projectcalico.org/master/networking/bgp"target="_blank" rel="external nofollow noopener noreferrer">https://docs.projectcalico.org/master/networking/bgp</a></p>
<p>Calico 维护的网络在默认是 <code>（Node-to-Node Mesh）全互联模式</code>，Calico集群中的节点之间都会相互建立连接，用于路由交换。但是随着集群规模的扩大，mesh模式将形成一个巨大服务网格，连接数成倍增加。这时就需要使用 Route Reflector（路由器反射）模式解决这个问题。确定一个或多个Calico节点充当路由反射器，让其他节点从这个RR节点获取路由信息。</p>
<p>在BGP中可以通过calicoctl node status看到启动是 node-to-node mesh 网格的形式，这种形式是一个全互联的模式，默认的BGP在k8s的每个节点担任了一个BGP的一个喇叭，一直吆喝着扩散到其他节点，随着集群节点的数量的增加，那么上百台节点就要构建上百台链接，就是全互联的方式，都要来回建立连接来保证网络的互通性，那么增加一个节点就要成倍的增加这种链接保证网络的互通性，这样的话就会使用大量的网络消耗，所以这时就需要使用Route reflector，也就是找几个大的节点，让他们去这个大的节点建立连接，也叫RR，也就是公司的员工没有微信群的时候，找每个人沟通都很麻烦，那么建个群，里面的人都能收到，所以要找节点或着多个节点充当路由反射器，建议至少是2到3个，一个做备用，一个在维护的时候不影响其他的使用。</p>
</div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="更新于 2024-01-08 00:00:00">更新于 2024-01-08&nbsp;</span>
      </div><div class="post-info-license">
          <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
        </div></div>
    <div class="post-info-line">
      <div class="post-info-md"><span><a href="/posts/kubernetes/primary/networking-implementation-in-kubernetes/index.md" title="阅读原始文档" class="link-to-markdown">阅读原始文档</a></span></div>
      <div class="post-info-share">
        <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://hg-xnlog.github.io/posts/kubernetes/primary/networking-implementation-in-kubernetes/" data-title="kubernetes 中的网络实现方式" data-hashtags="kubernetes网络,cni,flannel,docker,calico"><i class="fa-brands fa-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://hg-xnlog.github.io/posts/kubernetes/primary/networking-implementation-in-kubernetes/" data-hashtag="kubernetes网络"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 WhatsApp" data-sharer="whatsapp" data-url="https://hg-xnlog.github.io/posts/kubernetes/primary/networking-implementation-in-kubernetes/" data-title="kubernetes 中的网络实现方式" data-web><i class="fa-brands fa-whatsapp fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://hg-xnlog.github.io/posts/kubernetes/primary/networking-implementation-in-kubernetes/" data-title="kubernetes 中的网络实现方式"><i data-svg-src="/lib/simple-icons/icons/line.min.svg" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://hg-xnlog.github.io/posts/kubernetes/primary/networking-implementation-in-kubernetes/" data-title="kubernetes 中的网络实现方式"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Myspace" data-sharer="myspace" data-url="https://hg-xnlog.github.io/posts/kubernetes/primary/networking-implementation-in-kubernetes/" data-title="kubernetes 中的网络实现方式" data-description=""><i data-svg-src="/lib/simple-icons/icons/myspace.min.svg" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Blogger" data-sharer="blogger" data-url="https://hg-xnlog.github.io/posts/kubernetes/primary/networking-implementation-in-kubernetes/" data-title="kubernetes 中的网络实现方式" data-description=""><i class="fa-brands fa-blogger fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="https://hg-xnlog.github.io/posts/kubernetes/primary/networking-implementation-in-kubernetes/" data-title="kubernetes 中的网络实现方式"><i class="fa-brands fa-evernote fa-fw" aria-hidden="true"></i></a>
  </span>
      </div>
    </div>
  </div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href='/tags/kubernetes%E7%BD%91%E7%BB%9C/' class="post-tag">kubernetes网络</a><a href='/tags/cni/' class="post-tag">cni</a><a href='/tags/flannel/' class="post-tag">flannel</a><a href='/tags/docker/' class="post-tag">Docker</a><a href='/tags/calico/' class="post-tag">calico</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/posts/kubernetes/primary/kubernetes-rbac-and-multi-user-instances/" class="post-nav-item" rel="prev" title="kubernetes RBAC鉴权机制与多用户实例"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>kubernetes RBAC鉴权机制与多用户实例</a>
      <a href="/posts/kubernetes/primary/kubernetes%E9%85%8D%E7%BD%AEimagepullsecrets%E7%A7%98%E9%92%A5%E6%9D%A5%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F/" class="post-nav-item" rel="next" title="kubernetes配置imagePullSecrets秘钥来拉取镜像">kubernetes配置imagePullSecrets秘钥来拉取镜像<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></main><footer class="footer">
    <div class="footer-container"><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2021 - 2024</span><span class="author" itemprop="copyrightHolder">
              <a href="https://github.com/ryanxin7"target="_blank" rel="external nofollow noopener noreferrer">Ryan</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div><div class="footer-line statistics"><span class="site-time" title='网站运行中……'><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden="true"></i><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor">
          <span id="busuanzi_container_site_uv" title='总访客数'><i class="fa-regular fa-user fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span><span id="busuanzi_container_site_pv" class="footer-divider" title='总访问量'><i class="fa-regular fa-eye fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span>
        </div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><a href="https://github.com/ryanxin7" title="在 GitHub 上查看源代码"target="_blank" rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><div id="mask"></div><div class="reading-progress-bar" style="left: 0;top: 0;"></div><noscript>
    <div class="noscript-warning">FixIt 主题在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><link rel="stylesheet" href="/lib/pace/themes/blue/pace-theme-minimal.css"><script src="/lib/autocomplete/autocomplete.min.js" defer></script><script src="/lib/algoliasearch/algoliasearch-lite.umd.min.js" defer></script><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/copy-tex.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async defer></script><script src="/lib/pace/pace.min.js" async defer></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","editLockTitle":"锁定可编辑代码块","editUnLockTitle":"解锁可编辑代码块","editable":true,"maxShownLines":80},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验。"},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"enablePWA":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"HFAFNY4NX2","algoliaIndex":"xn-log","algoliaSearchKey":"bd08388586b2f88b20753c17c60ba92f","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"siteTime":"2021-09-09T09:09:09+09:00"};</script><script src="/js/theme.min.js" defer></script></body>
</html>
