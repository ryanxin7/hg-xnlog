<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>Kafka 集群实战与原理分析线上问题优化 - Ryan&#39;s Notebook</title><meta name="author" content="Ryan">
<meta name="author-link" content="https://github.com/ryanxin7">
<meta name="description" content="Kafka 集群实战与原理分析线上问题优化 一、为什么使用消息队列? 1.Kafka知识点思维导图 以电商为业务背景 消息队列解决的具体问题是什么？ &ndash; 通信问题" /><meta name="keywords" content='Kafka, Zookeeper, 中间件' /><meta itemprop="name" content="Kafka 集群实战与原理分析线上问题优化">
<meta itemprop="description" content="Kafka 集群实战与原理分析线上问题优化 一、为什么使用消息队列? 1.Kafka知识点思维导图 以电商为业务背景 消息队列解决的具体问题是什么？ &ndash; 通信问题"><meta itemprop="datePublished" content="2021-12-04T00:00:00+00:00" />
<meta itemprop="dateModified" content="2021-12-04T00:00:00+00:00" />
<meta itemprop="wordCount" content="6864"><meta itemprop="image" content="https://hg-xnlog.github.io/logo.png"/>
<meta itemprop="keywords" content="Kafka,Zookeeper,中间件," /><meta property="og:title" content="Kafka 集群实战与原理分析线上问题优化" />
<meta property="og:description" content="Kafka 集群实战与原理分析线上问题优化 一、为什么使用消息队列? 1.Kafka知识点思维导图 以电商为业务背景 消息队列解决的具体问题是什么？ &ndash; 通信问题" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hg-xnlog.github.io/posts/zookeeper/kafka01/" /><meta property="og:image" content="https://hg-xnlog.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-04T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-12-04T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://hg-xnlog.github.io/logo.png"/>

<meta name="twitter:title" content="Kafka 集群实战与原理分析线上问题优化"/>
<meta name="twitter:description" content="Kafka 集群实战与原理分析线上问题优化 一、为什么使用消息队列? 1.Kafka知识点思维导图 以电商为业务背景 消息队列解决的具体问题是什么？ &ndash; 通信问题"/>
<meta name="application-name" content="Ryan’s Notebook">
<meta name="apple-mobile-web-app-title" content="Ryan’s Notebook"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/images/favicon.svg"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://hg-xnlog.github.io/posts/zookeeper/kafka01/" /><link rel="prev" href="https://hg-xnlog.github.io/posts/elk/elk-practice/" /><link rel="next" href="https://hg-xnlog.github.io/posts/notes/git/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Kafka 集群实战与原理分析线上问题优化",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/hg-xnlog.github.io\/posts\/zookeeper\/kafka01\/"
    },"genre": "posts","keywords": "Kafka, Zookeeper, 中间件","wordcount":  6864 ,
    "url": "https:\/\/hg-xnlog.github.io\/posts\/zookeeper\/kafka01\/","datePublished": "2021-12-04T00:00:00+00:00","dateModified": "2021-12-04T00:00:00+00:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "Ryan"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper" data-page-style="wide"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper" data-github-corner="right">
    <div class="header-title">
      <a href="/" title="Ryan&#39;s Notebook"><img loading="lazy" src="/images/pow.png" srcset="/images/pow.png, /images/pow.png 1.5x, /images/pow.png 2x" sizes="auto" data-title="Ryan&#39;s Notebook" data-alt="Ryan&#39;s Notebook" class="logo" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/><span class="header-title-text">Ryan’s Notebook</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/posts/"
                
                
              ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 所有文章</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/friends/"
                title="友情链接"
                
              ><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden="true"></i> 友链</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/about/"
                
                
              ><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden="true"></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id="search-desktop">
            <input type="text" placeholder="搜索文章标题或内容……" id="search-input-desktop">
            <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
              <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
            </a>
            <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
              <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
            </a>
            <span class="search-button search-loading" id="search-loading-desktop">
              <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
            </span>
          </li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="Ryan&#39;s Notebook"><img loading="lazy" src="/images/pow.png" srcset="/images/pow.png, /images/pow.png 1.5x, /images/pow.png 2x" sizes="auto" data-title="/images/pow.png" data-alt="/images/pow.png" class="logo" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/><span class="header-title-text">Ryan’s Notebook</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="search-wrapper">
            <div class="search mobile" id="search-mobile">
              <input type="text" placeholder="搜索文章标题或内容……" id="search-input-mobile">
              <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
              </a>
              <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
              </a>
              <span class="search-button search-loading" id="search-loading-mobile">
                <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
              </span>
            </div>
            <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
              取消
            </a>
          </li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/posts/"
                  
                  
                ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 所有文章</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/friends/"
                  title="友情链接"
                  
                ><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden="true"></i> 友链</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/about/"
                  
                  
                ><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden="true"></i> 关于</a></li><li
              class="menu-item text-center"
            ><a
                  class="menu-link"
                  href="https://github.com/ryanxin7/hg-xnlog"
                  title="GitHub"
                  rel="noopener noreferrer" target="_blank"
                ><i class='fa-brands fa-github fa-fw' aria-hidden='true'></i> </a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="切换主题"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
  </div>
  <div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
  </div><main class="container"><aside class="toc" id="toc-auto"><h2 class="toc-title">目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside>

  <aside class="aside-custom">
    </aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>Kafka 集群实战与原理分析线上问题优化</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><a href="https://github.com/ryanxin7" title="作者"target="_blank" rel="external nofollow noopener noreferrer author" class="author"><img loading="lazy" src="/images/avatar.png" srcset="/images/avatar.png, /images/avatar.png 1.5x, /images/avatar.png 2x" sizes="auto" data-title="Ryan" data-alt="Ryan" class="avatar" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/>&nbsp;Ryan</a></span>
          <span class="post-category">收录于 <a href="/categories/kafka/"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> Kafka</a></span></div>
      <div class="post-meta-line"><span title="发布于 2021-12-04 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden="true"></i><time datetime="2021-12-04">2021-12-04</time></span>&nbsp;<span title="更新于 2021-12-04 00:00:00"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden="true"></i><time datetime="2021-12-04">2021-12-04</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>约 6864 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>预计阅读 14 分钟</span>&nbsp;<span id="busuanzi_container_page_pv" class="busuanzi_visitors comment-visitors" data-flag-title="Kafka 集群实战与原理分析线上问题优化">
            <i class="fa-regular fa-eye fa-fw me-1" aria-hidden="true"></i><span id="busuanzi_value_page_pv">-</span>&nbsp;次阅读
          </span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#一为什么使用消息队列">一、为什么使用消息队列?</a>
      <ul>
        <li><a href="#1kafka知识点思维导图">1.Kafka知识点思维导图</a></li>
        <li><a href="#2使用同步的通讯方式来解决多个服务之间的通讯">2.使用同步的通讯方式来解决多个服务之间的通讯</a></li>
        <li><a href="#3使用异步通讯方式">3.使用异步通讯方式</a></li>
      </ul>
    </li>
    <li><a href="#二消息队列的流派">二、消息队列的流派</a>
      <ul>
        <li><a href="#1什么是mq-">1.什么是MQ ？</a></li>
        <li><a href="#2中间件选型">2.中间件选型</a></li>
      </ul>
    </li>
    <li><a href="#三kafka的基本知识">三、Kafka的基本知识</a>
      <ul>
        <li><a href="#31--kafka的特性">3.1  Kafka的特性:</a></li>
        <li><a href="#32-kafka的使用场景">3.2 Kafka的使用场景</a></li>
        <li><a href="#32-基本概念">3.2 基本概念</a></li>
        <li><a href="#33-创建主题topic">3.3 创建主题topic</a></li>
        <li><a href="#34-发送消息">3.4 发送消息</a></li>
        <li><a href="#35-消费消息">3.5 消费消息</a></li>
        <li><a href="#36-关于消息的细节">3.6 关于消息的细节</a></li>
        <li><a href="#37单播消息">3.7单播消息</a></li>
        <li><a href="#38-多播消息">3.8 多播消息</a></li>
        <li><a href="#39-查看消费组的详细信息">3.9 查看消费组的详细信息</a></li>
      </ul>
    </li>
    <li><a href="#四kafka-中主题和分区的概念">四、Kafka 中主题和分区的概念</a>
      <ul>
        <li><a href="#41-主题topic">4.1 主题Topic</a></li>
        <li><a href="#42-partition-分区">4.2 partition 分区</a></li>
        <li><a href="#43-kafka-中消息日志文件中保存的内容">4.3 kafka 中消息日志文件中保存的内容</a></li>
      </ul>
    </li>
    <li><a href="#五kafka集群操作">五、Kafka集群操作</a>
      <ul>
        <li><a href="#51-搭建kafka集群三个broker">5.1 搭建kafka集群（三个broker）</a></li>
        <li><a href="#52-副本的概念">5.2 副本的概念</a></li>
        <li><a href="#53-关于集群消费">5.3 关于集群消费</a></li>
        <li><a href="#54-分区分消费组的集群消费中的细节">5.4 分区分消费组的集群消费中的细节</a></li>
      </ul>
    </li>
    <li><a href="#六专题1--kafka-集群controller-rebalance-和hw">六、专题1  Kafka 集群Controller 、Rebalance 和HW</a>
      <ul>
        <li><a href="#1controller">1.controller</a></li>
        <li><a href="#2rebalance机制">2.rebalance机制</a></li>
      </ul>
    </li>
    <li><a href="#七专题2-kafka中的优化问题面试问题">七、专题2 Kafka中的优化问题(面试问题)</a>
      <ul>
        <li><a href="#1如何防止消息丢失">1.如何防止消息丢失</a></li>
        <li><a href="#2如何防重复消费">2.如何防⽌重复消费</a></li>
        <li><a href="#3如何做到消息的顺序消费">3.如何做到消息的顺序消费</a></li>
        <li><a href="#4如何解决消息积压问题">4.如何解决消息积压问题</a></li>
        <li><a href="#5实现延时队列的效果">5.实现延时队列的效果</a></li>
      </ul>
    </li>
    <li><a href="#八kafka-eagle监控平台">八、Kafka-eagle监控平台</a>
      <ul>
        <li><a href="#1搭建">1.搭建</a></li>
        <li><a href="#1使用">1.使用</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><h1 id="kafka-集群实战与原理分析线上问题优化">Kafka 集群实战与原理分析线上问题优化</h1>
<h2 id="一为什么使用消息队列">一、为什么使用消息队列?</h2>
<h3 id="1kafka知识点思维导图">1.Kafka知识点思维导图</h3>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-LinuxKafka%e9%9b%86%e7%be%a4%e5%ae%9e%e6%88%98.jpg" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-LinuxKafka%e9%9b%86%e7%be%a4%e5%ae%9e%e6%88%98.jpg, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-LinuxKafka%e9%9b%86%e7%be%a4%e5%ae%9e%e6%88%98.jpg 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-LinuxKafka%e9%9b%86%e7%be%a4%e5%ae%9e%e6%88%98.jpg 2x" sizes="auto" data-title="Kafka集群实战" data-alt="Kafka集群实战" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>以电商为业务背景</p>
<p>消息队列解决的具体问题是什么？  &ndash; 通信问题。</p>
<!-- raw HTML omitted -->
<h3 id="2使用同步的通讯方式来解决多个服务之间的通讯">2.使用同步的通讯方式来解决多个服务之间的通讯</h3>
<!-- raw HTML omitted -->
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e8%ae%a2%e5%8d%95%e5%9c%ba%e6%99%af.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e8%ae%a2%e5%8d%95%e5%9c%ba%e6%99%af.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e8%ae%a2%e5%8d%95%e5%9c%ba%e6%99%af.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e8%ae%a2%e5%8d%95%e5%9c%ba%e6%99%af.png 2x" sizes="auto" data-title="订单场景" data-alt="订单场景" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>同步的通讯方式会存在性能和稳定性的问题。</p>
<!-- raw HTML omitted -->
<h3 id="3使用异步通讯方式">3.使用异步通讯方式</h3>
<!-- raw HTML omitted -->
<p>在业务的上游与下游间加入  通讯模块 （消息队列 存储消息的队列）</p>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e9%80%9a%e8%ae%af%e6%96%b9%e5%bc%8f.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e9%80%9a%e8%ae%af%e6%96%b9%e5%bc%8f.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e9%80%9a%e8%ae%af%e6%96%b9%e5%bc%8f.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e9%80%9a%e8%ae%af%e6%96%b9%e5%bc%8f.png 2x" sizes="auto" data-title="消息队列通讯方式" data-alt="消息队列通讯方式" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p><strong>最终一致性</strong></p>
<p>针对同步的通讯方式来说，异步的方式，可以让上游快速成功，极大提高了系统的吞吐量。而且在分布式系统中，通过下游多个服务的分布式事务保障，也能保证业务执行之后的最终一致性。</p>
<!-- raw HTML omitted -->
<h2 id="二消息队列的流派">二、消息队列的流派</h2>
<h3 id="1什么是mq-">1.什么是MQ ？</h3>
<p>Message Queue（MQ），消息队列中间件。<!-- raw HTML omitted -->
很多人都说：<!-- raw HTML omitted -->
MQ 通过将消息的发送和接收分离来实现应用程序的异步和解偶，这个给人的直觉是——MQ 是异步的，用来解耦的，但是这个只是 MQ 的效果而不是目的。<!-- raw HTML omitted -->
<!-- raw HTML omitted --></p>
<p>MQ 真正的目的是为了通讯，屏蔽底层复杂的通讯协议，定义了一套应用层的、更加简单的通讯协议。<!-- raw HTML omitted --></p>
<p>一个分布式系统中两个模块之间通讯要么是 HTTP，要么是自己开发的 TCP，但是这两种协议其实都是原始的协议。<!-- raw HTML omitted -->
HTTP 协议很难实现两端通讯——模块 A 可以调用 B，B 也可以主动调用 A，如果要做到这个两端都要背上 WebServer，而且还不支持长连接（HTTP 2.0 的库根本找不到）。
TCP 就更加原始了，粘包、心跳、私有的协议，想一想头皮就发麻。</p>
<p>MQ 所要做的就是在这些协议之上构建一个简单的“协议”——生产者/消费者模型。</p>
<p>MQ 带给我的“协议”不是具体的通讯协议，而是更高层次通讯模型。
它定义了两个对象——发送数据的叫生产者，接收数据的叫消费者；
提供一个 SDK 让我们可以定义自己的生产者和消费者实现消息通讯而无视底层通讯协议。</p>
<!-- raw HTML omitted -->
<h3 id="2中间件选型">2.中间件选型</h3>
<p>目前消息队列的中间件选型有很多种：</p>
<p>rabbit MQ：内部可玩性（功能性）是非常强的</p>
<p>rocket MQ  :阿里内部大神根据Kafka的内部执行原理，手写的一个消息中间件。性能比肩kafka，除此之外，在功能上封装了更多的功能。（消息的逆序）
kafka：全球消息处理性能最快的一款MQ（纯粹）</p>
<p>zeroMQ</p>
<p>这些消息队列中间件有什么区别？</p>
<p>我们把消息队列分为两种</p>
<p>MQ，分为有Broker的MQ，和没有Broker的MQ。
Broker，代理，经纪人的意思。</p>
<!-- raw HTML omitted -->
<h4 id="21有broker">2.1有broker</h4>
<p>有broker的MQ
这个流派通常有一台服务器作为Broker，所有的消息都通过它中转。生产者把消息发送给它就结束自己的任务了，Broker则把消息主动推送给消费者（或者消费者主动轮询）。</p>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e6%9c%89broker.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e6%9c%89broker.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e6%9c%89broker.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e6%9c%89broker.png 2x" sizes="auto" data-title="有broker" data-alt="有broker" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>重topic：Kafka 、RocketMQ 、 ActiveMQ
整个broker，依据topic来进行消息的中转，在重topic的消息队列里必然需要topic的存在</p>
<p>轻topic：RabbitMQ
topic只是其一种中转模式。
<!-- raw HTML omitted --></p>
<h4 id="22无broker">2.2无broker</h4>
<p>在生产者和消费者之间没有使用broker，例如zeroMQ，直接使用socket进行通信</p>
<p>无broker的MQ代表是ZeroMQ，该作者非常睿智，他非常敏锐的意识到&ndash;MQ是更高级的Socket</p>
<p>它是解决通信问题的。所以ZeroMQ被设计成了一个“库”而不是一个中间件，这种实现也可以达到&ndash;没有Broker的目的。</p>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e6%97%a0broker.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e6%97%a0broker.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e6%97%a0broker.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux%e6%97%a0broker.png 2x" sizes="auto" data-title="无broker" data-alt="无broker" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<!-- raw HTML omitted -->
<h2 id="三kafka的基本知识">三、Kafka的基本知识</h2>
<p>Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统.  <!-- raw HTML omitted -->
它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：  <!-- raw HTML omitted -->
比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。  <!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<h3 id="31--kafka的特性">3.1  Kafka的特性:</h3>
<ul>
<li>
<p>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。</p>
</li>
<li>
<p>可扩展性：kafka集群支持热扩展</p>
</li>
<li>
<p>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</p>
</li>
<li>
<p>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</p>
</li>
<li>
<p>高并发：支持数千个客户端同时读写</p>
</li>
</ul>
<!-- raw HTML omitted -->
<h3 id="32-kafka的使用场景">3.2 Kafka的使用场景</h3>
<ul>
<li>
<p>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</p>
</li>
<li>
<p>消息系统：解耦和生产者和消费者、缓存消息等。</p>
</li>
<li>
<p>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</p>
</li>
<li>
<p>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</p>
</li>
</ul>
<!-- raw HTML omitted -->
<h3 id="32-基本概念">3.2 基本概念</h3>
<p>kafka是一个分布式的，分区的消息(官方称之为commit log)服务。它提供一个消息系统应该具备的功能，但是确有着独特的设计。<!-- raw HTML omitted --></p>
<p>首先，让我们来看一下基础的消息(Message)相关术语：<!-- raw HTML omitted --></p>
<p>kafka 中有这么些复杂的概念<!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Broker</td>
<td>消息中间件处理节点，一个kafka节点就是一个broker，一个或多个Broker可以组成一个kafka集群。</td>
</tr>
<tr>
<td>Topic</td>
<td>kafka根据Topic对消息进行分类，发布到kafka集群的每条消息都需要指定一个Topic</td>
</tr>
<tr>
<td>Producer</td>
<td>消息生产者，向Broker发送消息的客户端</td>
</tr>
<tr>
<td>Consumer</td>
<td>消息消费者，从Broker读取消息的客户端</td>
</tr>
<tr>
<td>ConsumerGroup</td>
<td>每个consumer属于一个特定的Consumer Group，一条消息可以被多个不同的Consumer消费，但是一个Consumer Group中只能有一个consumer能消费该消息</td>
</tr>
<tr>
<td>Partition</td>
<td>物理上的概念，一个topic可以分为多个partition，每个partition内部消息是有序的</td>
</tr>
</tbody>
</table>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5.png 2x" sizes="auto" data-title="kafka基本概念" data-alt="kafka基本概念" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/>
<!-- raw HTML omitted --></p>
<h3 id="33-创建主题topic">3.3 创建主题topic</h3>
<p><strong>topic kafka消息逻辑的划分</strong><!-- raw HTML omitted --></p>
<p>topic是什么概念? topic可以实现消息的分类，不同消费者订阅不同的topic。<!-- raw HTML omitted --></p>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux20220111104851.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux20220111104851.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux20220111104851.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linux20220111104851.png 2x" sizes="auto" data-title="20220111104851" data-alt="20220111104851" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>执行以下命令创建名为&quot;test&quot;的topic，这个topic只有一个partition，并且备份因子也设置为1;</p>
<div class="highlight" id="id-1"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">./kafka-topics.sh --create --zookeeper 172.16.253.35:2181 --replication-factor <span class="m">1</span> --partitions <span class="m">1</span> --topic test</span></span></code></pre></div><p>查看当前kafka内有哪些topic</p>
<div class="highlight" id="id-2"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">./ kafka-topics.sh --list --zookeeper 172.16.253.35:2181</span></span></code></pre></div><!-- raw HTML omitted -->
<h3 id="34-发送消息">3.4 发送消息</h3>
<p>kafka自带了一个producer命令客户端，可以从本地文件中读取内容，或者我们也可以以命令行中直接输入内容，并将这些内容以消息的形式发送到kafka集群中。在默认情况下，每一个行会被当做成一个独立的消息。
<!-- raw HTML omitted -->
使用kafka的发送消息的客户端，指定发送到的kafka服务器地址和topic</p>
<div class="highlight" id="id-3"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">./kafka-console-producer.sh --broker-list 10.31.167.10:9092 --topic test</span></span></code></pre></div><h3 id="35-消费消息">3.5 消费消息</h3>
<p>对于consumer, kafka同样也携带了一个命令行客户端，会将获取到内容在命令中进行输出，默认是消费最新的消息。使用kafka的消费者消息的客户端，从指定kafka服务器的指定topic中消费消息</p>
<!-- raw HTML omitted -->
<ul>
<li>方式一:从当前主题中最后一条消息的offset（偏移量）+1开始消费</li>
</ul>
<div class="highlight" id="id-4"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">./kafka-console-consumer.sh --bootstrap-server 10.31.167.10:9092 --topic test</span></span></code></pre></div><ul>
<li>方式二∶从当前主题中的第一条消息开始消费</li>
</ul>
<div class="highlight" id="id-5"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">./kafxa-console-consumer.sh --bootstrap-server 10.31.167.10:9092 --from-beginning --topic test</span></span></code></pre></div><h3 id="36-关于消息的细节">3.6 关于消息的细节</h3>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%b6%88%e8%b4%b9%e7%bb%86%e8%8a%82.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%b6%88%e8%b4%b9%e7%bb%86%e8%8a%82.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%b6%88%e8%b4%b9%e7%bb%86%e8%8a%82.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%b6%88%e8%b4%b9%e7%bb%86%e8%8a%82.png 2x" sizes="auto" data-title="kafka消费细节" data-alt="kafka消费细节" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<ol>
<li>
<p>生产者将消息发送给broker，broker会将消息保存在本地的日志文件中<!-- raw HTML omitted -->
<code>/usr/ local/kafka/data/kafka-logs/主题-分区/0000000o.log</code></p>
</li>
<li>
<p>消息的保存是有序的，通过offset偏移量来描述消息的有序性</p>
</li>
<li>
<p>消费者消费消息时也是通过offset来描述当前要消费的那条消息的位置</p>
</li>
</ol>
<!-- raw HTML omitted -->
<h3 id="37单播消息">3.7单播消息</h3>
<p>在一个kafka的topic中，启动两个消费者，一个生产者，问:生产者发送消息，这条消息是否同时会被两个消费者消费?<!-- raw HTML omitted --></p>
<p>如果多个消费者在同一个消费组，那么只有一个消费者可以收到订阅的topic中的消息。换言之，同一个消费组中只能有一个消费者收到一个topic中的消息。</p>
<div class="highlight" id="id-6"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">./kafka-console-consumer.sh --bootstrap-server 172.16.253.38:9092--consumer-property group.id<span class="o">=</span>testGroup --topic test</span></span></code></pre></div><!-- raw HTML omitted -->
<h3 id="38-多播消息">3.8 多播消息</h3>
<p>不同的消费组订阅同一个topic，那么不同的消费组中只有一个消费者能收到消息。实际上也是多个消费组中的多个消费者收到了同一个消息。</p>
<div class="highlight" id="id-7"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">./kafka-console-consumer.sh --bootstrap-server 172.16.253.38:9092--consumer-property group.id<span class="o">=</span>testGroupl --topic test</span></span></code></pre></div><div class="highlight" id="id-8"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">./kafka-console-consumer.sh --bootstrap-server 172.16.253.38:9092--consumer-property group.id<span class="o">=</span>testGroup2 --topic test</span></span></code></pre></div><p><strong>下图就是描述多播和单播消息的区别:</strong></p>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%a4%9a%e6%92%ad%e4%b8%8e%e5%8d%95%e6%92%ad%e6%b6%88%e6%81%af%e7%9a%84%e5%8c%ba%e5%88%ab.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%a4%9a%e6%92%ad%e4%b8%8e%e5%8d%95%e6%92%ad%e6%b6%88%e6%81%af%e7%9a%84%e5%8c%ba%e5%88%ab.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%a4%9a%e6%92%ad%e4%b8%8e%e5%8d%95%e6%92%ad%e6%b6%88%e6%81%af%e7%9a%84%e5%8c%ba%e5%88%ab.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%a4%9a%e6%92%ad%e4%b8%8e%e5%8d%95%e6%92%ad%e6%b6%88%e6%81%af%e7%9a%84%e5%8c%ba%e5%88%ab.png 2x" sizes="auto" data-title="kafka多播与单播消息的区别" data-alt="kafka多播与单播消息的区别" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<!-- raw HTML omitted -->
<h3 id="39-查看消费组的详细信息">3.9 查看消费组的详细信息</h3>
<p>通过以下命令可以查看到消费组的相信信息︰</p>
<pre tabindex="0"><code>./kafka-consumer-groups.sh --bootstrap-server 172.16.253.38:9092 --describe --group testGroup</code></pre><!-- raw HTML omitted -->
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%9f%a5%e7%9c%8b%e6%b6%88%e8%b4%b9%e7%bb%84%e8%af%a6%e7%bb%86%e4%bf%a1%e6%81%af.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%9f%a5%e7%9c%8b%e6%b6%88%e8%b4%b9%e7%bb%84%e8%af%a6%e7%bb%86%e4%bf%a1%e6%81%af.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%9f%a5%e7%9c%8b%e6%b6%88%e8%b4%b9%e7%bb%84%e8%af%a6%e7%bb%86%e4%bf%a1%e6%81%af.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%9f%a5%e7%9c%8b%e6%b6%88%e8%b4%b9%e7%bb%84%e8%af%a6%e7%bb%86%e4%bf%a1%e6%81%af.png 2x" sizes="auto" data-title="kafka查看消费组详细信息" data-alt="kafka查看消费组详细信息" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<!-- raw HTML omitted -->
<p><strong>重点关注以下几个信息∶</strong></p>
<ul>
<li>current-offset:最后被消费的消息的偏移量</li>
<li>Log-end-offset:消息总量(最后一条消息的偏移量)</li>
<li>Lag:积压了多少条消息</li>
</ul>
<!-- raw HTML omitted -->
<h2 id="四kafka-中主题和分区的概念">四、Kafka 中主题和分区的概念</h2>
<!-- raw HTML omitted -->
<h3 id="41-主题topic">4.1 主题Topic</h3>
<p>主题-topic在kafka中是一个逻辑的概念，kafka通过topic将消息进行分类。不同的topic会被订阅该topic的消费者消费。<!-- raw HTML omitted --></p>
<p>但是有一个问题，如果说这个topic中的消息非常非常多，多到需要几T来存，因为消息是会被保存到log日志文件中的。为了解决这个文件过大的问题, kafka提出了Partition分区的概念
<!-- raw HTML omitted -->
<!-- raw HTML omitted --></p>
<h3 id="42-partition-分区">4.2 partition 分区</h3>
<!-- raw HTML omitted -->
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%88%86%e5%8c%ba.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%88%86%e5%8c%ba.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%88%86%e5%8c%ba.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%88%86%e5%8c%ba.png 2x" sizes="auto" data-title="kafka分区" data-alt="kafka分区" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<!-- raw HTML omitted -->
<p><strong>1)分区的概念</strong></p>
<p>通过partition将一个topic中的消息分区来存储。</p>
<p>这样的好处有多个:</p>
<ul>
<li>
<p>分区存储，可以解决统一存储文件过大的问题</p>
</li>
<li>
<p>提供了读写的吞吐量:读和写可以同时在多个分区中进行</p>
</li>
</ul>
<!-- raw HTML omitted -->
<p><strong>2)创建多分区的主题</strong></p>
<div class="highlight" id="id-10"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">./kafka-topics.sh --create --zokeeper 172.16.253.35:2181 --replication-factor l --partitions <span class="m">2</span> --topic test1</span></span></code></pre></div><!-- raw HTML omitted -->
<h3 id="43-kafka-中消息日志文件中保存的内容">4.3 kafka 中消息日志文件中保存的内容</h3>
<p><code>. 00000.log:</code>这个文件中保存的就是消息
<code>_consumer_offsets-49</code></p>
<p>kafka内部自己创建了_consumer_offsets主题包含了50个分区。这个主题用来存放消费者消费某个主题的偏移量。</p>
<p>因为每个消费者都会自己维护着消费的主题的偏移量，也就是说每个消费者会把消费的主题的偏移量自主上报给kafka中的默认主题<code>consumer_offsets</code>。因此kafka为了提升这个主题的并发性，默认设置了50个分区。(可以通过offsets.topic.num.paritions设置)，这样可以通过加机器的方式抗大并发。</p>
<ul>
<li>
<p>提交到哪个分区︰通过hash函数: hash(consumerGroupld) %_consumer_offsets主题的分区数</p>
</li>
<li>
<p>提交到该主题中的内容是: key是consumerGroupld+topic+分区号，value就是当前offset的值</p>
</li>
<li>
<p>文件中保存的消息，kafka会定期清理topic里的消息，最后就保留最新的那条数据默认保存7天。七天到后消息会被删除。</p>
</li>
</ul>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-offsets50%e9%bb%98%e8%ae%a4%e4%b8%bb%e9%a2%98.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-offsets50%e9%bb%98%e8%ae%a4%e4%b8%bb%e9%a2%98.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-offsets50%e9%bb%98%e8%ae%a4%e4%b8%bb%e9%a2%98.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-offsets50%e9%bb%98%e8%ae%a4%e4%b8%bb%e9%a2%98.png 2x" sizes="auto" data-title="kafka-offsets50默认主题" data-alt="kafka-offsets50默认主题" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<!-- raw HTML omitted -->
<h2 id="五kafka集群操作">五、Kafka集群操作</h2>
<h3 id="51-搭建kafka集群三个broker">5.1 搭建kafka集群（三个broker）</h3>
<!-- raw HTML omitted -->
<p>创建三个<code>server.properties</code>文件</p>
<div class="highlight" id="id-11"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1">#0 1 2</span>
</span></span><span class="line"><span class="cl">broker.id<span class="o">=</span><span class="m">2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#9092 9093 9094</span>
</span></span><span class="line"><span class="cl"><span class="nv">listeners</span><span class="o">=</span>PLAINTEXT ://192.168.65.60:9094
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#kafka-logs kafka-logs-1 kafka-logs-2</span>
</span></span><span class="line"><span class="cl">log.dir<span class="o">=</span>/usr/ local/ data/ kafka-logs-2</span></span></code></pre></div><!-- raw HTML omitted -->
<div class="highlight" id="id-12"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">./ kafka-server-start.sh -daemon ../config/server.properties
</span></span><span class="line"><span class="cl">./ kafka-server-start.sh -daemon ../config/server1.properties
</span></span><span class="line"><span class="cl">./ kafka-server-start.sh -daemon ../config/server2.properties</span></span></code></pre></div><!-- raw HTML omitted -->
<p>校验是否启动成功</p>
<div class="highlight" id="id-13"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">进入到zk中查看/brokers/ids中过是否有三个znode <span class="o">(</span>0,1,2<span class="o">)</span></span></span></code></pre></div><!-- raw HTML omitted -->
<h3 id="52-副本的概念">5.2 副本的概念</h3>
<p>在创建主题时，除了指明了主题的分区数以外，还指明了副本数，那么副本是一个什么概念呢?<!-- raw HTML omitted --></p>
<p>副本是为了为主题中的分区创建多个备份，多个副本在kafka集群的多个broker中，会有一个副本作为leader，其他是follower。 生产者与消费者只会与leader交互消息，而follower只会与leader保持同步以备不时之需。<!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%89%af%e6%9c%ac%e6%a6%82%e5%bf%b5.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%89%af%e6%9c%ac%e6%a6%82%e5%bf%b5.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%89%af%e6%9c%ac%e6%a6%82%e5%bf%b5.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%89%af%e6%9c%ac%e6%a6%82%e5%bf%b5.png 2x" sizes="auto" data-title="kafka副本概念" data-alt="kafka副本概念" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>leader: kafka的写和读的操作，都发生在leader上。leader负责把数据同步给follower。当leader挂了，经过主从选举，从多个follower中选举产生一个新的leader</p>
</li>
<li>
<p>follower： 接收leader的同步的数据</p>
</li>
<li>
<p>isr:  可以同步和已同步的节点会被存入到isr集合中。这里有一个细节︰如果isr中的节点性能较差，会被提出isr集合。)</p>
</li>
</ul>
<p><strong>理解:</strong> 集群中有多个broker，创建主题时可以指明主题有多个分区(把消息拆分到不同的分区中存储)，可以为分区创建多个副本，不同的副本存放在不同的broker里。</p>
<!-- raw HTML omitted -->
<h3 id="53-关于集群消费">5.3 关于集群消费</h3>
<ol>
<li>向集群发送消息∶</li>
</ol>
<div class="highlight" id="id-14"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">./kafka-console-consumer . sh --bootstrap-server 172.16.253.38:9092,172.16.253.38:9093,172.16.253.38:9094 --from-beginning --consumer-property group.id<span class="o">=</span>testGroupl --topic my-replicated-topic</span></span></code></pre></div><ol start="2">
<li>从集群中消费消息</li>
</ol>
<div class="highlight" id="id-15"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">./kafka-console-producer .sh --broker-list 172.16.253.38:9092,172.16.253.38:9093,172.16.253.38:9094 --topicmy-replicated-topic</span></span></code></pre></div><ol start="3">
<li>指定消费组来消费消息</li>
</ol>
<div class="highlight" id="id-16"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">./kafka-console-consumer .sh --bootstrap-server 172.16.253.38∶9092,172.16.253.38:9093,172.16.253.38:9094 --from-beginning --consumer-property group.id<span class="o">=</span>testGroupl --topic my-replicated-topic</span></span></code></pre></div><!-- raw HTML omitted -->
<h3 id="54-分区分消费组的集群消费中的细节">5.4 分区分消费组的集群消费中的细节</h3>
<!-- raw HTML omitted -->
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%88%86%e5%8c%ba%e5%88%86%e6%b6%88%e8%b4%b9%e7%bb%84%e7%9a%84%e9%9b%86%e7%be%a4%e6%b6%88%e8%b4%b9%e4%b8%ad%e7%9a%84%e7%bb%86%e8%8a%82.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%88%86%e5%8c%ba%e5%88%86%e6%b6%88%e8%b4%b9%e7%bb%84%e7%9a%84%e9%9b%86%e7%be%a4%e6%b6%88%e8%b4%b9%e4%b8%ad%e7%9a%84%e7%bb%86%e8%8a%82.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%88%86%e5%8c%ba%e5%88%86%e6%b6%88%e8%b4%b9%e7%bb%84%e7%9a%84%e9%9b%86%e7%be%a4%e6%b6%88%e8%b4%b9%e4%b8%ad%e7%9a%84%e7%bb%86%e8%8a%82.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%88%86%e5%8c%ba%e5%88%86%e6%b6%88%e8%b4%b9%e7%bb%84%e7%9a%84%e9%9b%86%e7%be%a4%e6%b6%88%e8%b4%b9%e4%b8%ad%e7%9a%84%e7%bb%86%e8%8a%82.png 2x" sizes="auto" data-title="kafka分区分消费组的集群消费中的细节" data-alt="kafka分区分消费组的集群消费中的细节" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<ol>
<li>一个partition只能被一个消费组中的一个消费者消费，目的是为了保证消费的顺序性，但是多个partion的多个消费者消费的总的顺序性是得不到保证的，那怎么做到消费的总顺序性呢?</li>
<li>partition的数量决定了消费组中消费者的数量，建议同一个消费组中消费者的数量不要超过partition的数量，否则多的消费者消费不到消息</li>
<li>如果消费者挂了，那么会触发rebalance机制（后面介绍)，会让其他消费者来消费该分区</li>
</ol>
<!-- raw HTML omitted -->
<h2 id="六专题1--kafka-集群controller-rebalance-和hw">六、专题1  Kafka 集群Controller 、Rebalance 和HW</h2>
<h3 id="1controller">1.controller</h3>
<p><strong>集群中谁来充当controller</strong> <!-- raw HTML omitted --></p>
<p>每个broker启动时会向zk创建一个临时序号节点，获得的序号最小的那个broker将会作为集群中的controller，负责这么几件事:</p>
<ol>
<li>
<p>当集群中有一个副本的leader挂掉，需要在集群中选举出一个新的leader，选举的规则是从isr集合中最左边获得。</p>
</li>
<li>
<p>当集群中有broker新增或减少，controller会同步信息给其他broker</p>
</li>
<li>
<p>当集群中有分区新增或减少，controller会同步信息给其他broker</p>
</li>
</ol>
<h3 id="2rebalance机制">2.rebalance机制</h3>
<p><strong>前提</strong>:消费组中的消费者没有指明分区来消费 <!-- raw HTML omitted --></p>
<p><strong>触发的条件</strong>:当消费组中的消费者和分区的关系发生变化的时候 <!-- raw HTML omitted --></p>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-rebalance%e6%9c%ba%e5%88%b6.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-rebalance%e6%9c%ba%e5%88%b6.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-rebalance%e6%9c%ba%e5%88%b6.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-rebalance%e6%9c%ba%e5%88%b6.png 2x" sizes="auto" data-title="kafka-rebalance机制" data-alt="kafka-rebalance机制" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p><strong>分区分配的策略</strong>:在rebalance之前， 分区怎么分配会有这么三种策略</p>
<ul>
<li>
<p>range: 根据公示计算得到每个消费消费哪几个分区:前面的消费者是分区总数/消费
者数量+1,之后的消费者是分区总数/消费者数量.</p>
</li>
<li>
<p>轮询:大家轮着来</p>
</li>
<li>
<p>sticky: 粘合策略，如果需要rebalance, 会在之前已分配的基础上调整，不会改变之前的分配情况。如果这个策略没有开，那么就要进行全部的重新分配。建议开启。</p>
</li>
</ul>
<!-- raw HTML omitted -->
<h2 id="七专题2-kafka中的优化问题面试问题">七、专题2 Kafka中的优化问题(面试问题)</h2>
<!-- raw HTML omitted -->
<h3 id="1如何防止消息丢失">1.如何防止消息丢失</h3>
<p>⽣产者：</p>
<ol>
<li>使⽤同步发送</li>
<li>把ack设成1（leader 成功写入）或者all(所有broker完成同步)，并且设置同步的分区数&gt;=2</li>
</ol>
<p>消费者：把⾃动提交改成⼿动提交<!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<h3 id="2如何防重复消费">2.如何防⽌重复消费</h3>
<p>在防⽌消息丢失的⽅案中，如果⽣产者发送完消息后，因为⽹络抖动，没有收到ack，但实际 上broker已经收到了。</p>
<p>此时⽣产者会进⾏重试，于是broker就会收到多条相同的消息，⽽造成消费者的重复消费。</p>
<p><strong>怎么解决</strong>：</p>
<p>⽣产者关闭重试：会造成丢消息（不建议） <!-- raw HTML omitted -->
消费者解决⾮幂等性消费问题： 所谓的幂等性：多次访问的结果是⼀样的。<!-- raw HTML omitted --></p>
<p>对于rest的请求（get（幂等）、post（⾮幂 等）、put（幂等）、delete（幂等））<!-- raw HTML omitted --></p>
<p>幂等：多次访问的结果是一样的<!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p><strong>解决⽅案</strong>：
在数据库中创建联合主键，防⽌相同的主键 创建出多条记录
使⽤分布式锁，以业务id为锁。保证只有⼀条记录能够创建成功</p>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%a6%82%e4%bd%95%e9%98%b2%e2%bd%8c%e9%87%8d%e5%a4%8d%e6%b6%88%e8%b4%b9.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%a6%82%e4%bd%95%e9%98%b2%e2%bd%8c%e9%87%8d%e5%a4%8d%e6%b6%88%e8%b4%b9.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%a6%82%e4%bd%95%e9%98%b2%e2%bd%8c%e9%87%8d%e5%a4%8d%e6%b6%88%e8%b4%b9.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%a6%82%e4%bd%95%e9%98%b2%e2%bd%8c%e9%87%8d%e5%a4%8d%e6%b6%88%e8%b4%b9.png 2x" sizes="auto" data-title="kafka如何防⽌重复消费" data-alt="kafka如何防⽌重复消费" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h3 id="3如何做到消息的顺序消费">3.如何做到消息的顺序消费</h3>
<ul>
<li>
<p>⽣产者：保证消息按顺序消费，且消息不丢失——使⽤同步的发送，ack设置成⾮0的 值。</p>
</li>
<li>
<p>消费者：主题只能设置⼀个分区，消费组中只能有⼀个消费者</p>
</li>
</ul>
<p>kafka的顺序消费使⽤场景不多，因为牺牲掉了性能，但是⽐如rocketmq在这⼀块有专⻔的功能已设计好</p>
<!-- raw HTML omitted -->
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%a6%82%e4%bd%95%e5%81%9a%e5%88%b0%e6%b6%88%e6%81%af%e7%9a%84%e9%a1%ba%e5%ba%8f%e6%b6%88%e8%b4%b9.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%a6%82%e4%bd%95%e5%81%9a%e5%88%b0%e6%b6%88%e6%81%af%e7%9a%84%e9%a1%ba%e5%ba%8f%e6%b6%88%e8%b4%b9.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%a6%82%e4%bd%95%e5%81%9a%e5%88%b0%e6%b6%88%e6%81%af%e7%9a%84%e9%a1%ba%e5%ba%8f%e6%b6%88%e8%b4%b9.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%a6%82%e4%bd%95%e5%81%9a%e5%88%b0%e6%b6%88%e6%81%af%e7%9a%84%e9%a1%ba%e5%ba%8f%e6%b6%88%e8%b4%b9.png 2x" sizes="auto" data-title="kafka如何做到消息的顺序消费" data-alt="kafka如何做到消息的顺序消费" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<!-- raw HTML omitted -->
<h3 id="4如何解决消息积压问题">4.如何解决消息积压问题</h3>
<p>1）消息积压问题的出现 <!-- raw HTML omitted --></p>
<p>消息的消费者的消费速度远赶不上⽣产者的⽣产消息的速度，导致kafka中有⼤量的数据没有被消费。<!-- raw HTML omitted --></p>
<p>随着没有被消费的数据堆积越多，消费者寻址的性能会越来越差，最后导致整个 kafka对外提供的服务的性能很差，从⽽造成其他服务也访问速度变慢，造成服务雪崩。</p>
<!-- raw HTML omitted -->
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%b6%88%e6%81%af%e7%a7%af%e5%8e%8b%e9%97%ae%e9%a2%98%e7%9a%84%e5%87%ba%e7%8e%b0.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%b6%88%e6%81%af%e7%a7%af%e5%8e%8b%e9%97%ae%e9%a2%98%e7%9a%84%e5%87%ba%e7%8e%b0.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%b6%88%e6%81%af%e7%a7%af%e5%8e%8b%e9%97%ae%e9%a2%98%e7%9a%84%e5%87%ba%e7%8e%b0.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%b6%88%e6%81%af%e7%a7%af%e5%8e%8b%e9%97%ae%e9%a2%98%e7%9a%84%e5%87%ba%e7%8e%b0.png 2x" sizes="auto" data-title="kafka消息积压问题的出现" data-alt="kafka消息积压问题的出现" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>2）消息积压的解决⽅案 <!-- raw HTML omitted --></p>
<ol>
<li>
<p>在这个消费者中，使⽤多线程，充分利⽤机器的性能进⾏消费消息。</p>
</li>
<li>
<p>通过业务的架构设计，提升业务层⾯消费的性能。</p>
</li>
<li>
<p>创建多个消费组，多个消费者，部署到其他机器上，⼀起消费，提⾼消费者的消费速度</p>
</li>
</ol>
<p>创建⼀个消费者，该消费者在kafka另建⼀个主题，配上多个分区，多个分区再配上多个 消费者。该消费者将poll下来的消息，不进⾏消费，直接转发到新建的主题上。此时，新 的主题的多个分区的多个消费者就开始⼀起消费了。——不常⽤</p>
<!-- raw HTML omitted -->
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%b6%88%e6%81%af%e7%a7%af%e5%8e%8b%e7%9a%84%e8%a7%a3%e5%86%b3%e2%bd%85%e6%a1%88.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%b6%88%e6%81%af%e7%a7%af%e5%8e%8b%e7%9a%84%e8%a7%a3%e5%86%b3%e2%bd%85%e6%a1%88.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%b6%88%e6%81%af%e7%a7%af%e5%8e%8b%e7%9a%84%e8%a7%a3%e5%86%b3%e2%bd%85%e6%a1%88.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e6%b6%88%e6%81%af%e7%a7%af%e5%8e%8b%e7%9a%84%e8%a7%a3%e5%86%b3%e2%bd%85%e6%a1%88.png 2x" sizes="auto" data-title="kafka消息积压的解决⽅案" data-alt="kafka消息积压的解决⽅案" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="5实现延时队列的效果">5.实现延时队列的效果</h3>
<p>1）应⽤场景 订单创建后，超过30分钟没有⽀付，则需要取消订单，这种场景可以通过延时队列来实现</p>
<p>2）具体⽅案</p>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%ae%9e%e7%8e%b0%e5%bb%b6%e6%97%b6%e9%98%9f%e5%88%97%e7%9a%84%e6%95%88%e6%9e%9c.png" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%ae%9e%e7%8e%b0%e5%bb%b6%e6%97%b6%e9%98%9f%e5%88%97%e7%9a%84%e6%95%88%e6%9e%9c.png, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%ae%9e%e7%8e%b0%e5%bb%b6%e6%97%b6%e9%98%9f%e5%88%97%e7%9a%84%e6%95%88%e6%9e%9c.png 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka%e5%ae%9e%e7%8e%b0%e5%bb%b6%e6%97%b6%e9%98%9f%e5%88%97%e7%9a%84%e6%95%88%e6%9e%9c.png 2x" sizes="auto" data-title="kafka实现延时队列的效果" data-alt="kafka实现延时队列的效果" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<ol>
<li>
<p>kafka中创建创建相应的主题</p>
</li>
<li>
<p>消费者消费该主题的消息(轮询)</p>
</li>
<li>
<p>消费者消费消息时判断消息的创建时间和当前时间是否超过30分钟(前提是订单没支付)</p>
</li>
<li>
<p>如果是:去数据库中修改订单状态为已取消</p>
</li>
<li>
<p>如果否:记录当前消息的offset,并不再继续消费之后的消息。等待1分钟后，再次向kafka拉取该offset及之后的消
息，继续进行判断，以此反复。</p>
</li>
</ol>
<!-- raw HTML omitted -->
<h2 id="八kafka-eagle监控平台">八、Kafka-eagle监控平台</h2>
<h3 id="1搭建">1.搭建</h3>
<p>去kafka-eagle官⽹下载压缩包
<a href="http://download.kafka-eagle.org/"target="_blank" rel="external nofollow noopener noreferrer">http://download.kafka-eagle.org/</a></p>
<p>分配⼀台虚拟机
虚拟机中安装jdk
解压缩kafka-eagle的压缩包
给kafka-eagle配置环境变量</p>
<p>export KE_HOME=/usr/local/kafka-eagle
export PATH=$PATH:$KE_HOME/bin</p>
<p>需要修改kafka-eagle内部的配置⽂件：
vim system-config.properties
修改⾥⾯的zk的地址和mysql的地址
进⼊到bin中，通过命令来启动</p>
<p>./ke.sh start</p>
<!-- raw HTML omitted -->
<h3 id="1使用">1.使用</h3>
<!-- raw HTML omitted -->
<p>kafka-eagle 监控面板</p>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-eagle-%e7%9b%91%e6%8e%a7%e9%9d%a2%e6%9d%bf.PNG" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-eagle-%e7%9b%91%e6%8e%a7%e9%9d%a2%e6%9d%bf.PNG, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-eagle-%e7%9b%91%e6%8e%a7%e9%9d%a2%e6%9d%bf.PNG 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-eagle-%e7%9b%91%e6%8e%a7%e9%9d%a2%e6%9d%bf.PNG 2x" sizes="auto" data-title="kafka-eagle-监控面板" data-alt="kafka-eagle-监控面板" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<!-- raw HTML omitted -->
<p>kafka-监控查看节点信息</p>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-%e7%9b%91%e6%8e%a7%e6%9f%a5%e7%9c%8b%e8%8a%82%e7%82%b9%e4%bf%a1%e6%81%af.PNG" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-%e7%9b%91%e6%8e%a7%e6%9f%a5%e7%9c%8b%e8%8a%82%e7%82%b9%e4%bf%a1%e6%81%af.PNG, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-%e7%9b%91%e6%8e%a7%e6%9f%a5%e7%9c%8b%e8%8a%82%e7%82%b9%e4%bf%a1%e6%81%af.PNG 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-%e7%9b%91%e6%8e%a7%e6%9f%a5%e7%9c%8b%e8%8a%82%e7%82%b9%e4%bf%a1%e6%81%af.PNG 2x" sizes="auto" data-title="kafka-监控查看节点信息" data-alt="kafka-监控查看节点信息" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<!-- raw HTML omitted -->
<p>kafka-eagle查看消费组与消费主题信息</p>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-eagle%e6%9f%a5%e7%9c%8b%e6%b6%88%e8%b4%b9%e7%bb%84%e6%b6%88%e8%b4%b9%e4%b8%bb%e9%a2%98%e4%bf%a1%e6%81%af.PNG" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-eagle%e6%9f%a5%e7%9c%8b%e6%b6%88%e8%b4%b9%e7%bb%84%e6%b6%88%e8%b4%b9%e4%b8%bb%e9%a2%98%e4%bf%a1%e6%81%af.PNG, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-eagle%e6%9f%a5%e7%9c%8b%e6%b6%88%e8%b4%b9%e7%bb%84%e6%b6%88%e8%b4%b9%e4%b8%bb%e9%a2%98%e4%bf%a1%e6%81%af.PNG 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-eagle%e6%9f%a5%e7%9c%8b%e6%b6%88%e8%b4%b9%e7%bb%84%e6%b6%88%e8%b4%b9%e4%b8%bb%e9%a2%98%e4%bf%a1%e6%81%af.PNG 2x" sizes="auto" data-title="kafka-eagle查看消费组消费主题信息" data-alt="kafka-eagle查看消费组消费主题信息" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<!-- raw HTML omitted -->
<p>kafka-eagle查看消息积压情况</p>
<p><img loading="lazy" src="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-eagle%e6%9f%a5%e7%9c%8b%e6%b6%88%e6%81%af%e7%a7%af%e5%8e%8b%e6%83%85%e5%86%b5.PNG" srcset="https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-eagle%e6%9f%a5%e7%9c%8b%e6%b6%88%e6%81%af%e7%a7%af%e5%8e%8b%e6%83%85%e5%86%b5.PNG, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-eagle%e6%9f%a5%e7%9c%8b%e6%b6%88%e6%81%af%e7%a7%af%e5%8e%8b%e6%83%85%e5%86%b5.PNG 1.5x, https://xin997.oss-cn-beijing.aliyuncs.com/xinblogs/webimg-Linuxkafka-eagle%e6%9f%a5%e7%9c%8b%e6%b6%88%e6%81%af%e7%a7%af%e5%8e%8b%e6%83%85%e5%86%b5.PNG 2x" sizes="auto" data-title="kafka-eagle查看消息积压情况" data-alt="kafka-eagle查看消息积压情况" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<!-- raw HTML omitted -->
</div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="更新于 2021-12-04 00:00:00">更新于 2021-12-04&nbsp;</span>
      </div><div class="post-info-license">
          <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
        </div></div>
    <div class="post-info-line">
      <div class="post-info-md"><span><a href="/posts/zookeeper/kafka01/index.md" title="阅读原始文档" class="link-to-markdown">阅读原始文档</a></span></div>
      <div class="post-info-share">
        <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://hg-xnlog.github.io/posts/zookeeper/kafka01/" data-title="Kafka 集群实战与原理分析线上问题优化" data-hashtags="Kafka,Zookeeper,中间件"><i class="fa-brands fa-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://hg-xnlog.github.io/posts/zookeeper/kafka01/" data-hashtag="Kafka"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 WhatsApp" data-sharer="whatsapp" data-url="https://hg-xnlog.github.io/posts/zookeeper/kafka01/" data-title="Kafka 集群实战与原理分析线上问题优化" data-web><i class="fa-brands fa-whatsapp fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://hg-xnlog.github.io/posts/zookeeper/kafka01/" data-title="Kafka 集群实战与原理分析线上问题优化"><i data-svg-src="/lib/simple-icons/icons/line.min.svg" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://hg-xnlog.github.io/posts/zookeeper/kafka01/" data-title="Kafka 集群实战与原理分析线上问题优化"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Myspace" data-sharer="myspace" data-url="https://hg-xnlog.github.io/posts/zookeeper/kafka01/" data-title="Kafka 集群实战与原理分析线上问题优化" data-description=""><i data-svg-src="/lib/simple-icons/icons/myspace.min.svg" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Blogger" data-sharer="blogger" data-url="https://hg-xnlog.github.io/posts/zookeeper/kafka01/" data-title="Kafka 集群实战与原理分析线上问题优化" data-description=""><i class="fa-brands fa-blogger fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="https://hg-xnlog.github.io/posts/zookeeper/kafka01/" data-title="Kafka 集群实战与原理分析线上问题优化"><i class="fa-brands fa-evernote fa-fw" aria-hidden="true"></i></a>
  </span>
      </div>
    </div>
  </div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href='/tags/kafka/' class="post-tag">Kafka</a><a href='/tags/zookeeper/' class="post-tag">Zookeeper</a><a href='/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/' class="post-tag">中间件</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/posts/elk/elk-practice/" class="post-nav-item" rel="prev" title="等保2.0项目-日志收集实践"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>等保2.0项目-日志收集实践</a>
      <a href="/posts/notes/git/" class="post-nav-item" rel="next" title="Git常用命令与常见问题">Git常用命令与常见问题<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></main><footer class="footer">
    <div class="footer-container"><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2021 - 2023</span><span class="author" itemprop="copyrightHolder">
              <a href="https://github.com/ryanxin7"target="_blank" rel="external nofollow noopener noreferrer">Ryan</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div><div class="footer-line statistics"><span class="site-time" title='网站运行中……'><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden="true"></i><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor">
          <span id="busuanzi_container_site_uv" title='总访客数'><i class="fa-regular fa-user fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span><span id="busuanzi_container_site_pv" class="footer-divider" title='总访问量'><i class="fa-regular fa-eye fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span>
        </div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><a href="https://github.com/ryanxin7" title="在 GitHub 上查看源代码"target="_blank" rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><div id="mask"></div><noscript>
    <div class="noscript-warning">FixIt 主题在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><link rel="stylesheet" href="/lib/pace/themes/blue/pace-theme-minimal.css"><script src="/lib/autocomplete/autocomplete.min.js" defer></script><script src="/lib/algoliasearch/algoliasearch-lite.umd.min.js" defer></script><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/copy-tex.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async defer></script><script src="/lib/pace/pace.min.js" async defer></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","editLockTitle":"锁定可编辑代码块","editUnLockTitle":"解锁可编辑代码块","editable":true,"maxShownLines":80},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验。"},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"enablePWA":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"HFAFNY4NX2","algoliaIndex":"xn-log","algoliaSearchKey":"bd08388586b2f88b20753c17c60ba92f","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"siteTime":"2021-09-09T09:09:09+09:00"};</script><script src="/js/theme.min.js" defer></script></body>
</html>
